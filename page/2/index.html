<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jackzhangqing.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="痛点才是奋斗点~">
<meta property="og:type" content="website">
<meta property="og:title" content="Qzhang">
<meta property="og:url" content="https://jackzhangqing.github.io/page/2/index.html">
<meta property="og:site_name" content="Qzhang">
<meta property="og:description" content="痛点才是奋斗点~">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Qzhang">
<meta property="article:tag" content="Liunx, Matlab, Python, Java, 算法, 编程技术, AI交叉应用">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jackzhangqing.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Qzhang</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Qzhang" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Qzhang</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">奔赴山海, 保持热爱</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/luumod" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jackzhangqing.github.io/2023/09/09/1-Scala%E4%B9%8B%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qzhang">
      <meta itemprop="description" content="痛点才是奋斗点~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qzhang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/09/1-Scala%E4%B9%8B%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">Scala之基础语法1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-09 18:23:09 / 修改时间：18:25:55" itemprop="dateCreated datePublished" datetime="2023-09-09T18:23:09+08:00">2023-09-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E4%B8%9A%E7%95%8C/" itemprop="url" rel="index"><span itemprop="name">工业界</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E4%B8%9A%E7%95%8C/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91Spark/" itemprop="url" rel="index"><span itemprop="name">大数据高级开发Spark</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>认识：</p>
<p>Scala 编程语言</p>
<p>  头等公民：对象 函数</p>
<p>  多范式的编程语言</p>
<pre><code>面向对象

函数式编程
</code></pre>
<p>  函数式编程 </p>
<pre><code>1.高阶函数

2.支持 闭包

3.类型推断

4.无副作用 无IO操作，不改变状态

5.引用透明 同一函数，传递相同参数，必然返回同一个结果。
</code></pre>
<p>  特点：</p>
<pre><code>1.多范式编程语言

2.多平台语言 JVM  .NET JS浏览器

3.与Java无缝兼容,类库互相调用

4.强大的类型推断

5.并发
</code></pre>
<p>  特性：feature</p>
<pre><code>柯里化

抽象控制

部分应用函数

偏函数
</code></pre>
<p>REPL 交互式解析器</p>
<p>  1.在命令行输入命令：</p>
<pre><code>scala 

进入交互式解析器。
</code></pre>
<p>  2.可以在交互式解析器中定义变量，方法，类，对象，特质等。</p>
<pre><code>定义完成之后直接编译
</code></pre>
<p>  3.常用命令</p>
<pre><code>:help

:quit :q

:load fileName 

:paste 
</code></pre>
<p>1.变量 val&#x2F;var</p>
<pre><code> eg: val/var 变量名:类型=值

 1.1 val 不可变的

     var 可变的

 1.2 声明与赋值同时定义

     只能对var赋默认值,参数类型必须给定,值为 _

     eg: var str:String=_
</code></pre>
<p>2.方法 def</p>
<pre><code>2.1 格式: 

  [修饰符] def methodName(name1:ArgsType1,name2:ArgsType2)[:retrunType]=&#123;

     //方法体

  &#125;

2.2 过程 方法的返回类型为Unit时，称之为过程（不建议大家这样做）

  eg:

    def test1(a:Int):Unit=&#123;&#125; 

      ----&gt; 可以变成如下写法：

    def test1(a:Int)&#123;&#125;

2.3 当方法为非递归方法时，可以将返回类型省略

    def test(a:Int)=&#123;

      a

    &#125;

  eg: 如下为递归方法，不可以将返回类型省略。

    def fac(a:Int):Int=&#123;

      a*fac(a-1)

    &#125;

2.4 方法调用 方法名(args)

  1.对于无参数的方法，方法调用有两种： 方法名() 或者 方法名

  2.方法调用时，可以通过形参进行无顺序传递。

    eg: def info(a:Int,b:Int,c:Int)=&#123;

          a+b+c

        &#125;

    方法调用：

      info(1,2,3)

      info(a=1,c=3,b=2)

    注意：当使用形参传递参数时，如果有未指明形参名的必须与对应位置想匹配，不可以随意放置。

      info(b=2,a=1,6) //正确

      info(b=2,6,a=1) //错误 形参a,b有对应的值，那么为c赋值时，需要按照c在方法参数列表中的位置进行对应。 

2.5 可变参列表

    1.只能位于参数列表的最后一个

    2.表示形式： 类型* 

    3.可变参本质上是一个集合。 

    def test(a:Int,b:String,c:Any*)=&#123;

      println(c)

    &#125;
</code></pre>
<p>3.统一类型-了解数据类型</p>
<pre><code>在Scala中，所有的值都有类型，包括数值和函数。下图阐述了类型层次结构的一个子集。

      Any （顶级父类，最顶级类）

  AnyVal    AnyRef(java.lang.Object)

    ^       List

    |       Option

  Double      YourClass

  Dloat       ^

  Long          |

  Int         |

  Short         |

  Byte        |

  Boolean       |

  Char        Null

  Unit        ^

    ^               |

    |         |

        Nothing（底部类型，所有类的子类，最底层类）

类层级结构：

          Any(顶级父类，最顶级类) 

  AnyVal        AnyRef(相当于Java中的Object)

8基本+Unit      引用类型

          Nothing(所有类的子类，最底层类)

Any是所有类型的超类型，也称为顶级类型。它定义了一些通用的方法如equals、hashCode和toString。Any有两个直接子类：AnyVal和AnyRef。

AnyVal代表值类型。有9个预定义的非空的值类型分别是：Double、Float、Long、Int、Short、Byte、Char、Unit和Boolean。Unit是不带任何意义的值类型，它仅有一个实例可以像这样声明：()。所有的函数必须有返回，所以说有时候Unit也是有用的返回类型。

值类型的空间是平坦的；所有的值类都是scala.AnyVal的子类型，但是它们不是其他类的子类。但是不同的值类类型之间可以隐式地互相转换。例如，需要的时候，类scala.Int的实例可以通过隐式转换放宽到类scala.Long的实例；Int支持min、max、until、to、abs等操作，其实是从类Int隐式转换到scala.runtime.RichInt的。

AnyRef代表引用类型。所有非值类型都被定义为引用类型。在Scala中，每个用户自定义的类型都是AnyRef的子类型。AnyRef其实是Java平台上java.lang.Object类的别名。因此Java里写的类和Scala里写的都继承自AnyRef。
</code></pre>
<p>如果Scala被应用在Java的运行环境中，AnyRef相当于java.lang.Object。</p>
<pre><code>Scala类与Java类的不同在于它们还继承自一个名为ScalaObject的特别记号特质。是想要通过ScalaObject包含的Scala编译器定义和实现的方法让Scala程序的执行更高效。

类型转化.

下面是一个示例，说明了字符串、整型、布尔值和函数都是对象，这一点和其他对象一样：

  val list: List[Any] = List(

    &quot;a string&quot;,

    732,  // an integer

    &#39;c&#39;,  // a character

    true, // a boolean value

    () =&gt; &quot;an anonymous function returning a string&quot;

  )

  list.foreach(element =&gt; println(element))

Nothing和Null

scala.Null和scala.Nothing是用统一的方式处理Scala面向对象类型系统的某些&quot;边界情况&quot;的特殊类型。

Nothing是所有类型的子类型，也称为底层类型。没有一个值是Nothing类型的。它的用途之一是给出非正常终止的信号，如抛出异常、程序退出或者一个无限循环（可以理解为它是一个不对值进行定义的表达式的类型，或者是一个不能正常返回的方法）。

Null是所有引用类型的子类型（即AnyRef的任意子类型）。它有一个单例值由关键字null所定义。Null主要是使得Scala满足和其他JVM语言的互操作性，但是几乎不应该在Scala代码中使用。我们将在后面的章节中介绍null的替代方案。

例1:

  def error(message: String): Nothing = throw new RuntimeException(message)

  def divide(x: Int, y: Int): Int = if(y != 0) x / y else error(&quot;Can&#39;t divide by zero&quot;)
</code></pre>
<p>4.类 class</p>
<p>  4.1 格式：class 类名 private[package] (主构造器参数列表) extends 类&#x2F;特质 with 特质1 with 特质2{}</p>
<pre><code>eg: class Student(name:String,age:Int) extends Father with T1 with T2&#123;

  //属性

  //方法

  //主构造器中的代码

  println(&quot;.....&quot;)

  def this()=&#123;

    //.......

  &#125;

&#125;
</code></pre>
<p>  4.2 构造器：</p>
<pre><code>  主构造器 : 与类的定义交织在一起

  辅助构造器 :  

    1.通过方法名this重载构造器 

    2.辅助构造器的第一行代码必须是调用主构造器或者调用其他已经定义好的辅助构造器
</code></pre>
<p>  4.3 主构造器参数列表</p>
<pre><code>形式：

  1.参数名:类型  

  2.var 参数名:类型

  3.val 参数名:类型

  4.private val/var 参数名:类型

  5.@BeanProperty val/var 参数名:类型

总结：

  1.当参数没有被修饰，且在类中没有使用该参数，该参数什么都不会生成。

  2.当参数被val修饰时，会生成private修饰的字段/属性，以及提供一个名字为参数名的公有取值方法。

  3.当参数被var修饰时，会生成private修饰的字段/属性，以及提供一个名字为参数名的公有取值方法和一个名字为参数名_=的公有赋值方法。

  4.与2,3生成的字段以及方法个数一致，不同在于生成的方法时私有的。

  5.@BeanProperty 会生成javaBean版本的set/get方法
</code></pre>
<p>5.对象 object 单例对象</p>
<pre><code>格式: object 对象名 extends 类/特质 with 特质1 with 特质2&#123;&#125;

总结: 

    类中的方法与字段都是非静态的。

    对象中的方法与字段都是静态的。

程序入口

  1.Main方法

    object TestMain1&#123;

      //程序入口

      def main(args:Array[String]):Unit=&#123;&#125;

    &#125;

    将代码写到TestMain1.scala文件中。

  2.扩展App

    object TestMain2 extends App&#123;

      //......程序入口

    &#125;

    将代码写到TestMain2.scala文件中。

准备工作: mkdir scala/day1

     vi TestMain1.scala

编译命令:

        scalac  TestMain1.scala

查看当前目录: ls 

        使用反编译工具打开 TestMain1.class

        scalap TestMain1

        javap -p TestMain1

运行命令:  

        scala TestMain1
</code></pre>
<p>6.特质 trait</p>
<pre><code>格式: trait 特质名 extends 类/特质 with 特质1 &#123;&#125;

总结: 

    1.可以包含具体方法/属性

    2.可以包含抽象方法/属性

    3.特质 可以 混入 类/对象/特质/实例(对象)
</code></pre>
<p>7.类型 type</p>
<pre><code>格式: type 变量名=类型

总结: 

    1.当类型名称比较复杂时，可以对当前类型起个别名，方便后期使用。

    2.当同一个源文件中出现两个不同包的同一类名时，可以通过类型别名来进行区分。
</code></pre>
<hr>
<p>编译操作:</p>
<p>1.编译</p>
<pre><code>1.1方式一scalac

    使用Scala的基本编译器——scalac。开始编译源文件，但在编译完成之前会有几秒的停顿。因为每次编译器启动时，都要花一些时间扫描jar文件内容，并且在开始编译提交的源文件之前完成更多其他初始化工作（因此可能比Java程序编译慢）。命令如下：

        scalac -d bin/ Hello.scala

1.2方式二fsc

    Scala的发布包里还包括了一个叫做fsc（快速Scala编译器，Fast Scala Compiler）的Scala编译器后台服务（daemon）。估计是针对Scala程序编译慢才刻意提供的服务。使用方法如下（其实用法和scalac差不多）：

        fsc -d bin/ Hello.scala

    第一次执行fsc时，会创建一个绑定在计算机端口上的本地服务器后台进程。然后它就会把文件列表通过端口发送给后台进程，由后台进程编译。下一次执行fsc时，检测到后台进程已经在运行了，于是fsc将只把文件列表发给后台进程，它会立刻开始编译文件。使用fsc，只须在首次运行的时候等待Java运行时环境的启动。如果想停止fsc后台进程，可以执行命令：

        fsc -shutdownh
</code></pre>
<p>2.打包</p>
<pre><code>打包过程和Java程序打包没什么两样，这里不做累述，仅给出命令行如下：

    jar -cvf hello.jar -C bin/ .
</code></pre>
<p>3.运行</p>
<pre><code>3.1方式一java

    使用java方式运行打包好的Scala程序有一个地方特别需要注意。这里，先看按Java程序的方式，不做任何处理运行Scala，命令行如下：

        java -cp hello.jar Hello 

    报错提示Scala中的方法没有找到，为什么没有找到？这里先声明：该程序在Eclipse for Scala（IDE）上运行是没问题的，所以问题可能出在Scala的jar包没有引入，那么用-D参数引入jar包，命令行如下：

        java -Djava.ext.dirs=$SCALA_CP -cp hello.jar Hello 

        （注：SCALA_CP=$SCALA_HOME/lib）

3.2方式二scala

    其实可以直接使用scala命令来运行的，不要以为scala命令只能开启Scala命令行模式，闲言少叙，直接看命令行：

        scala -cp hello.jar Hello 
</code></pre>
<p>4.总结</p>
<p>  如果多次编译Scala程序建议使用fsc（每一种事物的存在都有它道理的），如果只须编译一次Scala程序，就用scalac吧，毕竟fsc用完记得关闭；</p>
<p>  运行Scala程序建议使用scala命令，不建议用java命令。</p>
<ol start="5">
<li><p>应用程序对象</p>
<p> 1.每个scala程序都必须从一个对象的main方法开始，这个方法的参数是Array[String]&#x3D;&gt;Unit</p>
<pre><code> object Hello&#123;

    def main(args: Array[String]): Unit = &#123;

     println(&quot;hello , scala ！&quot;)

    &#125;

 &#125;
</code></pre>
<p> 2.除了提供自己的main方法之外，也可以扩展App特质，然后将程序代码放入构造方法体内：</p>
<pre><code> object Hello extends App&#123;

    println(&quot;Hello , hadoop ! &quot;)

 &#125;

如果需要命令行参数，则可以通过args属性得到：

 object Hello extends App&#123;

    if(args.length &gt; 0)

     println(&quot;Hello , &quot;+args(0))

    else 

     println(&quot;hello , scala !&quot;)

 &#125;

如果在调用该应用程序时设置了scala.time选项的话，程序退出时会显示逝去的时间。

 eg:

     scalac Hello.scala

     scala -Dscala.time Hello briup

 App特质扩展自另一个特质DelayedInit,编译器对该特质有特殊处理。所有带有该特质的类，其初始化方法都会被挪到delayedInit方法中.App特质的main方法捕获到命令行从那时，调用delayedInit方法,并且还可以根据要求打印出逝去的时间。
</code></pre>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jackzhangqing.github.io/2023/09/09/Scala%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E4%BC%98%E7%82%B9%E3%80%81%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qzhang">
      <meta itemprop="description" content="痛点才是奋斗点~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qzhang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/09/Scala%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E4%BC%98%E7%82%B9%E3%80%81%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Scala的定义、优点、如何使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-09 18:20:58 / 修改时间：18:23:41" itemprop="dateCreated datePublished" datetime="2023-09-09T18:20:58+08:00">2023-09-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E4%B8%9A%E7%95%8C/" itemprop="url" rel="index"><span itemprop="name">工业界</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E4%B8%9A%E7%95%8C/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91Spark/" itemprop="url" rel="index"><span itemprop="name">大数据高级开发Spark</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.scala是什么</p>
<pre><code>1.1定义

    1.scala是一门编程语言

    2.多范式的编程语言

        面向对象编程

        面向函数式编程 

    3.支持多平台的编程语言 

        JVM  .NET 浏览器(JS)

    4.可扩展编程语言scalable language 

        Scala语言写出来的程序具有很灵活的可扩展性

        举例:

            1.Tuple 元组:元组用来存在不同类型的数据

            2.trait 特质:相当于java里的接口，只是它允许有方法体，并且可以在类实例化的时候混入，而不用修改原代码。

trait Logger&#123;

    def log(msg:String)=&#123;

        val  fos:FileOutputStream=new FileOutputStream(new File(&quot;path&quot;));

        fos.write(msg.getBytes());

        fos.flush();

        fos.close();

    &#125;

&#125;

//1.

//study()

val stu1=new Student();

stu1.study();

//2.study() log()日志记录

val stu2=new Student() with  Logger;

stu2.log(&quot;....&quot;)

1.2函数式编程

    1）函数式编程是种编程方式，它将电脑运算视为函数的计算。函数编程语言最重要的基础是λ演算(lambda calculus),而且λ演算的函数可以接受函数当作输入(参数)和输出(返回值)。

    简单说，&quot;函数式编程&quot;是一种&quot;编程范式&quot;（programming paradigm），也就是如何编写程序的方法论。

    它属于&quot;结构化编程&quot;的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。

    举例:

        (1+2)/3

        (1.+(2))./(3)

        //stu.setName().setAge().setPhone()

        val lastData=data.filter(过滤条件/函数).map(转化);

    2）函数式编程一般都包括以下特性 
</code></pre>
<p>   1.支持高阶函数 </p>
<p>   2.支持 闭包</p>
<pre><code>def add(a:Int,b:Int):Int=&#123;a+b&#125;

def add(a:Int):Int=&gt;Int=&#123;

    (b:Int)=&gt;a+b

&#125;

//柯里化函数

def add(a:Int)(b:Int)=&#123;a+b&#125;

val f1=add(2);//a=2

val value1=f1(3);//b=3 
</code></pre>
<p>   3.支持类型推断 </p>
<p>   4.尽可能编写”纯函数” foreach</p>
<pre><code>            1.无副作用 无IO操作，不改变状态

            2.引用透明 同一函数，传递相同参数，必然返回同一个结果。

    3.函数式编程优点
</code></pre>
<p>      1）代码简洁,开发快速</p>
<p>      2）接近自然语言,易于理解</p>
<pre><code>            函数式编程的自由度很高，可以写出很接近自然语言的代码。
</code></pre>
<p>          将表达式(1 + 2) * 3 - 4，写成函数式语言：</p>
<p>                      subtract(multiply(add(1,2), 3), 4)</p>
<p>          对它进行变形，不难得到另一种写法：</p>
<p>                    add(1,2).multiply(3).subtract(4)</p>
<p>       3）更方便的代码管理</p>
<p>           函数式编程不依赖、也不会改变外界的状态，只要给定输入参数，返回的结果必定相同。因此，每一个函数都可以被看做独立单元，很有利于进行单元测试（unit testing）和除错（debugging），以及模块化组合。</p>
<p>        4）易于”并发编程”</p>
<p>          函数式编程不需要考虑”死锁”（deadlock），因为它不修改变量，所以根本不存在”锁”线程的问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心地把工作分摊到多个线程，部署”并发编程”（concurrency）。</p>
<pre><code>            多核CPU是将来的潮流，所以函数式编程的这个特性非常重要。
</code></pre>
<p>       5）代码的热升级</p>
<p>          函数式编程没有副作用，只要保证接口不变，内部实现是外部无关的。所以，可以在运行状态下直接升级代码，不需要重启，也不需要停机。Erlang语言早就证明了这一点，它是瑞典爱立信公司为了管理电话系统而开发的，电话系统的升级当然是不能停机的。</p>
<pre><code>    4.Scala函数式编程的特性feature

        柯里化函数

        部分应用函数

        偏函数

        抽象控制
</code></pre>
<p>2.为什么学习Scala（scala的优点）</p>
<pre><code>Spark 

    Scala/Java/R/Python/SQL	

1.可扩展性

2.兼容Java

    可以与java无缝结合，可以直接调用java类，可以互相转化

    String IO

3.语法简洁

    代码行短

    类型推断

    抽象控制 class  do while 

4.静态类型语言 Java Scala

    编译(时确定变量类型)检查

5.支持并发控制

    采用akka Actor模型，更好的处理并发问题

    Java中并发处理是Thread,但是线程特别容易造成资源竞争问题，我们可以通过加锁的方式解决竞争问题，但是随之可能会造成死锁等问题，处理起来比较繁琐。

    Actor模型与传统模型不一样，它很好的解决了资源竞争和死锁的问题，

    我们可以把一个由actor模型实现的并发程序看成一个星系，每个星球就是一个actor,每个actor之间不共享资源，但是每个星球都有一个类似于信箱的东西，用来和不同的actor之间进行信息交流，它会按照信件的先后顺序依次处理信息，根据信息类型触发不同的行为。同时，每个星球可以异步给其他星球发送信息，也就是它发送消息之后，不需要等待回复消息，而是继续它自己的操作。
</code></pre>
<p>3.如何学习</p>
<pre><code>1.基础语法
</code></pre>
<p>         1.REPL交互式解析器</p>
<p>         2.声明定义</p>
<p>             变量&#x2F;方法&#x2F;类&#x2F;对象&#x2F;特质&#x2F;类型</p>
<p>          3.主程序入口</p>
<p>          4.表达式</p>
<p>             if 块&#x2F;复合表达式</p>
<p>          5.循环</p>
<p>             do&#x2F;while for–&gt;for推导</p>
<p>          6.包与包对象</p>
<pre><code>2.高级特性
</code></pre>
<p>          1.面向对象编程</p>
<p>              类&#x2F;对象&#x2F;伴生对象&#x2F;样例类&#x2F;抽象类&#x2F;特质</p>
<p>              继承&#x2F;重写&#x2F;重载</p>
<p>          2.容器集合</p>
<p>                数组&#x2F;数组缓冲&#x2F;元组&#x2F;Map&#x2F;Seq&#x2F;Set</p>
<pre><code>    3.模式匹配

    4.函数式编程

        函数/高阶函数/柯里化函数/部分应用函数/偏函数/控制抽象

    5.类型系统

        泛型/类型界定/类型约束

    6.隐式操作/转化

        隐式方法/类/对象/参数/值	
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jackzhangqing.github.io/2023/09/09/Scala%E8%AF%AD%E8%A8%80%E7%BB%AA%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qzhang">
      <meta itemprop="description" content="痛点才是奋斗点~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qzhang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/09/Scala%E8%AF%AD%E8%A8%80%E7%BB%AA%E8%AE%BA/" class="post-title-link" itemprop="url">Scala语言绪论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-09 18:11:27 / 修改时间：18:19:33" itemprop="dateCreated datePublished" datetime="2023-09-09T18:11:27+08:00">2023-09-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E4%B8%9A%E7%95%8C/" itemprop="url" rel="index"><span itemprop="name">工业界</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E4%B8%9A%E7%95%8C/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91Spark/" itemprop="url" rel="index"><span itemprop="name">大数据高级开发Spark</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1、安装认识Scala<br>2、了解Scala中的类型<br>3、如何声明定义变量<br>4、如何定义类&#x2F;方法&#x2F;对象&#x2F;特质（接口&#x2F;抽象类） 任何一门语言需要学习的3项<br>5、for表达式   》进阶map  foreach<br>6、数组集合的使用<br>7、模式匹配的使用<br>8、函数式编程   （需要好好学）<br>        函数<br>        高阶函数<br>        柯里化函数<br>        偏函数<br>        部分应用函数</p>
<p>Scala（Scalable language：可伸缩的语言）语言是一门多范式的编程语言，类似java。是Spark的源码。是面对对象的语言（封装、继承、多态）。函数式编程语言。在分布式计算、数据挖掘、web开发。</p>
<p>jre的运行环境：JVM（JDK）</p>
<p>scala：<br>      1）spark  分布式计算框架   （已经代替了MapReduce   hive）</p>
<p>      2）Kafka   消息队列       </p>
<p>特点：1、兼容java<br>        一般在scala调用java。<br>      2、语法简洁<br>        代码行短<br>        类型推断<br>        抽象控制（特质）<br>      3、静态类型化（java scala）而Python是动态类型语言<br>         可检验（编译进行检查）</p>
<p>         安全重构</p>
<p>      4、支持并发控制（java是线程,而scala是akka actor）</p>
<p>         强化计算能力</p>
<p>         自定义其他控制结构</p>
<p>      5、可拓展</p>
<p>         面向对象</p>
<p>         函数式编程</p>
<p>1、安装scala和IDE编程工具。注意：把scala-2.12.8目录移动到不包含中文空格特殊字符的目录下D：&#x2F;Spark这个目录下。配置环境scala的变量。scala -version查看是否scala安装成功。</p>
<p>  IDEA</p>
<p>           new  Project</p>
<p>                      new Model</p>
<p>Eclipse</p>
<p>           new Workspace</p>
<p>                      new Project</p>
<p>2、scala类型</p>
<p>     超类（父类）      Any</p>
<p>  1）AnyVal（值类型）</p>
<p>一共9种</p>
<p> 四类八种所谓的Java基本数据类型（整数 Byte Short Int Long、浮点数 Float Double、字符 Char、布尔 Boolean）+Unit （空的意思；作用：替代void关键字，无返回值类型，返回值的类型为Unit；值：( ) { }）   可以用（）和{  }进行给Unit赋值。</p>
<p>  在java中：public  void  show(String info){     }</p>
<p>   &#x3D;&#x3D;》在scala中：def show (info:String):Unit&#x3D;{  println(info);    }               注意：首字母大写</p>
<p>  2）AnyRef（引用类型—–》Object）&#x2F;&#x2F;父类</p>
<p>         包括  I 自定义Scala类型   </p>
<p>                  II数组  Array</p>
<p>                  III集合   Map   Set   Seq（List）</p>
<p>                            HashSet  TreeSet  ArrayBuffer</p>
<p>                  IV在scala中引用Java自定义类型,即调用已经写好了的java。</p>
<p>                        java.lang.String是引用类型。相当于java的父类。</p>
<p>3、如何声明定义变量</p>
<p>         java格式：</p>
<p>                         变量  变量名 &#x3D; 值；</p>
<p>                          int  a &#x3D; 10；</p>
<p> 1）scala格式：</p>
<p>    val   var  是scala中定义变量的关键字。</p>
<p>    val   &#x2F;    var     变量名：变量类型  &#x3D;  值 （分号可以不用写）</p>
<p>            简化后（省略了变量类型，类型推断）： val  变量名 &#x3D;值            &#x2F;&#x2F;val a &#x3D; 10</p>
<p>            val  var的区别：</p>
<p>                    val 定义常量，不能修改（被final修饰的变量）</p>
<p>                    var 定义变量，可以修改。</p>
<p>            scala中的变量的声明与定义必须一起进行。</p>
<p>                 2） 今后在scala中定义使用中val多，建议在大数据中尽量全部使用val定义。因为并行计算的操作共享数据的原因。</p>
<p>                  3）  scala中的默认值【整数都是0，浮点数都是0.0，布尔类型是false，字符类型为‘   ’，字符串都是String是null，Unit为（ ）】  </p>
<p>               var  变量名：变量类型&#x3D; _（_表示默认值；在判断默认值类型时，必须用var，且变量类型不能省）</p>
<p>         eg：</p>
<p>                val a：Int&#x3D;10</p>
<p>                var str ：String&#x3D;”hello,scala”</p>
<p>                 val f:Float&#x3D;3.14F (要加一个F，表明是float类型，而直接3.14则是double类型）</p>
<hr>
<p>                 val f:Any&#x3D;3.14</p>
<hr>
<p>                  “hello”表示是字符串类型 </p>
<hr>
<p>                   val a：AnyVal&#x3D;“hello”</p>
<p>                   val  ref：AnyRef&#x3D;“hello”</p>
<p>4、如何定义类&#x2F;方法&#x2F;对象&#x2F;特质（接口&#x2F;抽象类）   </p>
<p>          1、class （类的关键字）主构造器与类的定义交织在一起。</p>
<p>               Java格式:</p>
<p>                            [修饰符] class 类名 [extends 父类 [implements 接口1,接口2]]{</p>
<p>                                                  属性</p>
<p>                                                   方法</p>
<p>                               }</p>
<p>                Scala格式: extends </p>
<p>                        [修饰符] class 类名[([主构造器参数列表])] [extends 父类 [with 特质1 with 特质2]] {</p>
<p>                                                &#x2F;&#x2F;1.属性</p>
<p>                                               &#x2F;&#x2F;2.方法</p>
<p>                                              &#x2F;&#x2F;3.除了1.2之外，其他的都属于主构造器内部的代码</p>
<p>                                   }</p>
<p>                         [修饰符] class 类名[(主构造器参数列表)] [extends 特质1] {</p>
<p>                                                     属性</p>
<p>                                                     方法</p>
<p>                            }</p>
<p>                         eg:</p>
<p>                                class Person{}</p>
<p>                              &#x2F;&#x2F;class Person(){}</p>
<p>                                 class Student(stuId:Int,name:String) extends Person {}</p>
<hr>
<pre><code>    1.主构造器参数列表中的格式:
</code></pre>
<p>          1.1(参数名1:参数类型,参数名2:参数类型,…..)</p>
<p>          1.2(val&#x2F;var 参数名1:参数类型,…..)</p>
<p>          1.3(private val&#x2F;var 参数名1:参数类型,….)</p>
<p>          1.4(@BeanProperty val&#x2F;var 参数名1:参数类型,…….)</p>
<hr>
<p>         *	val的作用:</p>
<p>                         1.将该参数(name)提升为类的私有属性</p>
<p>                         2.给私有属性提供公有的getXXX(name)方法</p>
<p>         * var的作用:</p>
<p>                         1.将该参数(age)提升为类的私有属性</p>
<p>                         2.给私有属性提供公有的getXXX(age)方法和setXXX(age_&#x3D;)方法</p>
<p>           * private的作用:</p>
<p>                         私有化所有的属性和方法</p>
<p>           * @BeanProperty的作用:</p>
<p>                         提供Java形式的getXXX&#x2F;setXXX方法</p>
<pre><code>    2.辅助构造器
</code></pre>
<p>         1）辅助构造器的方法名字必须为this;</p>
<p>         2）辅助构造器中第一行代码必须调用主构造器或者是已经定义好的其他辅助构造器;</p>
<hr>
<p>          2、def   （方法的关键字）</p>
<p>                 Java的格式:</p>
<p>                                 [修饰符] 返回类型 方法名([参数列表]){方法体}</p>
<p>                Scala的格式:</p>
<p>                                 [修饰符] def 方法名([参数列表]):返回类型&#x3D;{方法体}</p>
<p>                eg:</p>
<p>                    def add(x:Int,y:Int):Int&#x3D;{</p>
<p>                           x+y</p>
<p>                       }</p>
<p>               简化形式1:</p>
<p>                             方法体中如果只有一行代码,没有省略&#x3D;的情况下,{}可以省略</p>
<p>                               def add(x:Int,y:Int):Int &#x3D; x+y</p>
<p>              简化形式2(类型推断,根据方法体(块语句)推断方法的返回类型):</p>
<p>                            方法不是递归方法时，返回类型可以省略</p>
<p>                               def add(x:Int,y:Int) &#x3D; x+y	</p>
<p>              简化形式3:</p>
<p>                             无参在定义时可以省略()</p>
<p>                            def test1()&#x3D;{val a&#x3D;10;val b&#x3D;20;a+b}</p>
<p>                            def test1&#x3D;{val a&#x3D;10;val b&#x3D;20;a+b}</p>
<p>                            调用:</p>
<p>                                  无参方法调用时两种方式:</p>
<p>                                   1）方法名()</p>
<p>                                   2）方法名</p>
<p>                简化形式4:(不建议)</p>
<p>                               方法的返回类型为Unit时,可以省略”:返回类型和&#x3D;”,称为”过程”</p>
<p>                                 def work(info:String):Unit&#x3D;{</p>
<p>                                   println(“Teacher的工作是:”+info)</p>
<p>                                  }</p>
<p>                                 def work(info:String){</p>
<p>                                   println(“Teacher的工作是:”+info)</p>
<p>                                  }</p>
<p>                表达式 块语句 {}是一个值 取决于表达式中最后一行代码</p>
<p>                 eg:</p>
<p>                    val a&#x3D;{</p>
<p>                               println(“start”);</p>
<p>                               val a&#x3D;10;</p>
<p>                               val b&#x3D;20; </p>
<p>                               val sum&#x3D;a+b;</p>
<p>                                sum</p>
<p>                    }</p>
<p>      &#x2F;&#x2F;类似于Java中的三目运算 (条件)?true的时候返回:false的时候返回</p>
<p>            val result&#x3D;if(条件){</p>
<p>                   代码块</p>
<p>            }else{</p>
<p>                   代码块</p>
<p>             }</p>
<p>           val pi&#x3D;3.14</p>
<p>           val result&#x3D;if(pi&gt;10)</p>
<p>               “大于”</p>
<p>            else</p>
<p>               “小于”</p>
<p>          val result&#x3D;if(pi&gt;10){“大于”}</p>
<pre><code>        等价于
</code></pre>
<p>           val result&#x3D;if(pi&gt;10){“大于”}else{}</p>
<p>          3、object   （对象的关键字） </p>
<p>             格式: [修饰符]  object  对象名 extends 类 with 特质1 with 特质2 {</p>
<p>                            对象体</p>
<p>                           &#x2F;&#x2F;(静态)属性</p>
<p>                          &#x2F;&#x2F;(静态)方法</p>
<p>                        }</p>
<p>              object中main方法是JVM的程序入口</p>
<p>                     def main(args:Array[String]):Unit&#x3D;{</p>
<p>                                &#x2F;&#x2F;main方法</p>
<p>                      }</p>
<p>              两个作用:</p>
<p>                          1.程序入口main所在地</p>
<p>                          2.单例对象  静态属性&#x2F;方法</p>
<p>                          3.伴生对象</p>
<p>                             class Student{ … }</p>
<p>                             object Student{ … …}</p>
<p>          4、trait  （特质的关键字）</p>
<p>                特质的格式:</p>
<p>                               [修饰符] trait 特质名 extends 类 with 特质1 with 特质2{}</p>
<p>                                      作用:与Java的接口一致</p>
<p>                                      语法:与抽象类一致</p>
<p>               eg:</p>
<p>                    trait Test1{</p>
<p>                                &#x2F;&#x2F;具体方法&#x2F;属性</p>
<p>                               def add(a:Int,b:Int)&#x3D;a+b</p>
<p>                                  val a:Int&#x3D;10</p>
<p>                               &#x2F;&#x2F;抽象方法&#x2F;属性</p>
<p>                               def sub(a:Int,b:Int):Int</p>
<p>                                  val b:Int</p>
<p>                     }		</p>
<p>5.for表达式—》进阶map foreach</p>
<p>        循环 for while do</p>
<p>        int i&#x3D;0</p>
<p>         while(i&lt;10){</p>
<p>             &#x2F;&#x2F;循环代码</p>
<p>             i++;</p>
<p>            }</p>
<p>           var i&#x3D;0</p>
<p>           while(i&lt;10){</p>
<p>            &#x2F;&#x2F;循环代码</p>
<p>             i+&#x3D;1</p>
<p>            }</p>
<pre><code>//Java使用for循环遍历数组

int[] a=&#123;1,2,4,6&#125;

for(int i=0;i

    System.out.println(a[i])

&#125;

Scala中的for推导(表达式)格式:

    for(发生器)&#123;

        循环体

    &#125;

    发生器: 变量 &lt;- 待遍历的数组/集合/对象/....

eg:  a是Scala中待遍历的数组/集合/对象

    val a = 1 to 10

    val a=1.to(10)

    for(elem &lt;- a)&#123;

        println(elem)

    &#125;

1.for+if守卫

    遍历输出集合中的偶数

2.for嵌套

3.for嵌套+if守卫

4.for+yield---》for推导 返回一个结果(集合)

for(发生器)yield&#123;

    循环体

&#125;
</code></pre>
<p>6.数组集合的使用</p>
<pre><code>数组分为:

    定长数组 Array[T] 相当于Java中数组

    可变数组 数组缓冲 scala.collection.mutable.ArrayBuffer(可变集合)

声明定义数组:

    1.借助类的构造器构建

        val arr:Array[Int]=new Array[Int](长度)

        val buffer=new ArrayBuffer[String]

    2.使用对象统一构建原则构建

        empty[T]

        apply(elem:T*)
</code></pre>
<hr>
<pre><code>操作数组:

    1.数组进行 赋值 取值

        arr(index)=10

        arr(index)

        //等价于

        arr.update(index,10)

        arr.apply(index)

    2.可变数组(集合) 添加元素 移除元素

        append/All(elem:T*) 追加

        insert/All(index:Int,elem:T*) 插入

        remove(index:Int)

        remove(index:Int,count:Int)

        drop(count:Int)  从左开始删除count个元素，

        dropRight(count:Int)从右开始删除count个元素

            注意:这两个方法不会修改原集合,返回一个新的集合。

        添加元素的方法:				++   ++:   ++=   ++=:   +:   +=   +=:

            1.包含一个+号 ，含义是添加单个元素

            2.包含两个+号 ，含义是添加集合

            3.不包含=号 ，含义是不修改原集合,返回一个新集合

            4.包含=号 ，含义是修改原集合

            5.包含:号 ，含义是插入元素

            6.不包含:号 ，含义是追加元素

        移除元素的方法:				-   --   --=   -=

        注意1:不推荐使用带:号的方法，效率低

        注意2:只有可变集合(mutable)才有带=号的方法

        注意3:对于两个集合(Set集合),求合集(union/++) 差集(diff/--) 交集(intersect/&amp;)
</code></pre>
<hr>
<pre><code>集合分类:

        Collection       	Map

        List  	Set   	HashMap TreeMap

    ArrayList 	HashSet

    LinkedList	Treeset

             Iterable(特质)

    Map映射(特质)   Set集(特质) 	 	Seq序列(特质)

    HashMap		  HashSet	  IndexedSeq(特质) LinearSeq(特质)

    TreeMap		  TreeSet		索引序列         线性序列

                                Vector	    	List(列表)

                                ArrayBuffer

    可变集合 scala.collection.mutable.*

    不可变集合 scala.collection.immutable.*

    Scala中默认构建的都是不可变的集合;(类似于val/var)
</code></pre>
<p>         1）如何构建集合对象(对象统一构建原则)</p>
<p>             对象.empty[T]</p>
<p>             对象.apply(elem1,elem2,…)</p>
<p>             val map&#x3D;TreeMap.empty[String,Int]</p>
<p>             val set1&#x3D;Set.empty[Double]</p>
<p>             val set2&#x3D;HashSet.empty[Float]</p>
<p>             val seq1&#x3D;Seq.empty[String]</p>
<p>             val seq2&#x3D;IndexedSeq.empty[String]</p>
<p>             val map1&#x3D;Set.apply(1.4,3.5,1.9,1.7)</p>
<p>                 &#x2F;&#x2F;等价与</p>
<p>             val map2&#x3D;Set(1.4,3.5,1.9,1.7)</p>
<p>          2）Map 映射 集合 键值对 key不允许重复</p>
<p>               特殊数据类型:元组Tuple,将一系列类型不同(不超过22个)的元素放在一个()里面，通过,分割,此时对象称为元组</p>
<p>            eg:val a&#x3D;(1,3.14,true,’C’,”String”)</p>
<pre><code>        二元元组:元组中的元素个数为2，其实就是一组键值对(Map集合中的元素) 

        二元元组的表现形式:

            (第一元,第二元)

            等价

            第一元-&gt;第二元

        val elem1=(1,&quot;java&quot;)

        val elem2=(2,&quot;scala&quot;)

        val elem3=3-&gt;&quot;python&quot;

        val map=Map.apply(elem1,elem2,elem3)

        元组的类型:(第一个元素的类型,第二个,.....)

        获取元组中的元素:

            元组._下标 下标从1开始

        val stu=(1,&quot;tom&quot;,23,&quot;110&quot;)

        val id=stu._1

        val name=stu._2

        val age=stu._3

        val phone=stu._4

        val (id,name,age,phone)=(1,&quot;tom&quot;,23,&quot;110&quot;)

        val (id,name,age,_)=(1,&quot;tom&quot;,23,&quot;110&quot;)

        //案例:计算一个字符串中每个字符出现的次数

        //计算&quot;hello,scala&quot;字符串中每个字符出现的次数

          def test2(str:String)=&#123;

            //1.构建一个可变的Map集合

            val map=mutable.Map.empty[Char,Int];

            //2.遍历字符串 获取每个字符

            for(c &lt;- str)&#123;

              //3.

              val count=map.getOrElse(c,0)+1

              //4.存储到Map集合

              map.+=(c-&gt;count)

            &#125;

            //5.遍历输出每个字符出现的次数

            for((c,num) &lt;- map)&#123;

              println(s&quot;字符 $c 出现了 $num 次&quot;)

            &#125;

          &#125;
</code></pre>
<p>         3）Set集合 集合中的元素不允许重复，不会记录先后顺序。</p>
<p>               HashSet </p>
<p>               TreeSet 带有排序功能的Set集合</p>
<p>               BitSet 存储非负连续整数时效率非常高</p>
<p>               (合集)并集++ 差集– 交集&amp;</p>
<p>         4）Seq集合 会记录元素进入集合的先后顺序,允许元素重复。</p>
<p>              IndexedSeq 索引序列 </p>
<p>             Vector 向量(不可变集合,ArrayBuffer的不可变版本)</p>
<p>             Range 范围(不可变集合)</p>
<p>             ArrayBuffer 数组缓冲(可变集合)</p>
<p>              LinearSeq 线性序列</p>
<p>             Stream 流</p>
<p>             Stack 栈</p>
<p>             Queue 队列</p>
<p>             List 列表  不可变列表</p>
<p>             ::  ::: Nil 空列表 head::tail</p>
<p>7.模式匹配的使用</p>
<pre><code>1.引入 if else switch case default

    格式: 

        val result=表达 match&#123;

            case v1 =&gt; 执行的代码1

            case v2 =&gt; 执行的代码2

            case v3 =&gt; ....

            case _ =&gt; ....

        &#125;

    1）表达式可以是什么？

        布尔类型的表达

        变量

        Seq集合/对象/数组/元组

    2）v1,v2...可以什么？

        常量/值 变量 Seq集合/对象/数组/元组 类型

    eg:

        val a=10

        val result:Unit=(a&gt;3) match&#123;

            case true =&gt; 

                println(a)

                val str=&quot;scala&quot;

                val strLen=str.length

                println(&quot;a大于3&quot;)

            case false =&gt; println(&quot;a小于3&quot;)

        &#125;

        a match&#123;

            case 1 =&gt; ...

            case 2 =&gt; ...

            case 10 =&gt; ....

        &#125;

        a match&#123;

            case x if x%2==0 =&gt; ...

            case x if x%3==0 =&gt; ...

            case _ =&gt; ....

        &#125;

        Seq(1,3,5) match&#123;

            case Seq(x) =&gt; ...

            case Seq(x,y) =&gt; ...

            case Seq(x,y,z) =&gt; ...

        &#125;

        val str:Any=&quot;hello,Scala&quot;

        str match&#123;

            case x:Int =&gt;  ....

            case x:Double if x%2==0.0 =&gt; ...

            case x:String =&gt; ..

            case x:Student =&gt;....

        &#125;
</code></pre>
<p>大数据技术</p>
<pre><code>服务于&quot;数据&quot; 

从 海量数据 中 挖掘出(数据ETL)  有用数据 提取(机器学习) 商业价值 。

Hadoop 

    Hdfs集群 分布式文件系统 存储海量数据

    Yarn集群 资源(计算资源)管理调度 

    MapReduce 分布式计算框架

    Spark 分布式计算框架 

    1个美工(HTML+CSS)+Java开发人员 

    【1个美工(HTML+CSS)+】前段开发人员+Java开发人员 

前后端分离

    后台 JAVAEE 

            SSH(Spring+Struct2+Hibernate) 

            SSM(Spring+Spring MVC+Mybatis)

    前台 

        HTML+CSS+JavaScripy(Jquery) 

            .JSP 动态页面 特殊的Servlet 特殊的Java类

        HTML5+CSS3+Vue
</code></pre>
<hr>
<pre><code>JavaEE开发

    三层架构

    Web 

    Service 业务逻辑层

    Dao 与数据库进行交互

大数据技术位于Dao层之下,不与其他JavaEE技术或者是前段技术进行交互,用户是无法直观看到结果的。
</code></pre>
<p>8.函数式编程</p>
<pre><code>val result=data.filter(筛选条件).map(转化数据格式)

函数

    字面量格式:

        (参数列表) =&gt; &#123;函数体&#125;

    eg:

        def add(a:Int,b:Int)=&#123;

            a+b

        &#125;

    匿名函数(一般作为参数使用):	

        (a:Int,b:Int) =&gt; &#123;a+b&#125;

    把匿名函数赋值给一个变量，那么这个变量即函数本身

        val fun1=(a:Int,b:Int) =&gt; &#123;a+b&#125;

    函数的调用:

        函数名(参数列表)

        fun1(1,2)

        如果是匿名函数的话，那么匿名函数的调用不能和定义分开，必须是定义+调用同时进行。语法为(匿名函数)(参数列表)。

        ((a:Int,b:Int) =&gt; &#123;a+b&#125;)(1,2)
</code></pre>
<hr>
<pre><code>    方法与函数有什么区别吗？

        一般情况下：两者不作区分。

        不同之处:

            1.方法名只是方法名，没有特殊含义

            2.函数名等于函数本身

            3.无参方法调用的时候:	

                方法名()

                方法名

            4.无参函数调用的时候:

                函数名()

            5.无参方法定义时可以省略(),函数不可以

                def test1()=10

                def test1=10

                val test2=()=&gt;&#123;10&#125;

                val test2= =&gt;&#123;10&#125; 不可以

函数类型:

    (参数列表的类型)=&gt;返回类型

    eg:				

        (a:Int,b:Int)=&gt;&#123;a+b&#125;

        类型为:

        (Int,Int)=&gt;Int

高阶函数:一个方法(函数)的参数或者返回值为函数，则此方法(函数)称为高阶函数。

    def method1(args1:(Int,Int)=&gt;Int):ReturnType=&#123;

        方法体

    (a:(Int)=&gt;Int,b:Int)=&gt;&#123;a(b)&#125;

    参数为函数时，如果代码片段较少，建议使用匿名函数，否则使用字面量函数或者是对象中的(静态)方法。
</code></pre>
<hr>
<pre><code>类型推断:

    1.函数体中只有一行代码，&#123;&#125;可以省略

    2.如果匿名函数直接当作参数进行传递时，匿名函数中的参数类型可以省略;如果匿名函数的参数只有一个，则参数列表()可以省略;如果匿名函数的参数在函数体中只使用了一次，可以用_来代替，并且省略&quot;参数列表=&gt;&quot;

    func2((x:Int)=&gt;&#123;scala.math.sqrt(x).toInt&#125;)

    func2((x:Int)=&gt;scala.math.sqrt(x).toInt)

    func2((x)=&gt;scala.math.sqrt(x).toInt)

    func2(x=&gt;scala.math.sqrt(x).toInt)

    func2(scala.math.sqrt(_).toInt)

    foreach高阶函数

    val range=1 to 10

    range.foreach((x:Int)=&gt;&#123;println(x)&#125;)

    range.foreach((x:Int)=&gt;println(x))

    range.foreach((x)=&gt;println(x))

    range.foreach(x=&gt;println(x))

    range.foreach(println _)

    range.foreach(println)

闭包:匿名函数以及匿名函数中所使用的非局部变量组成闭包函数。

    eg:

        def mul(a:Int)=&#123;

            (b:Int)=&gt;&#123;a*b&#125;

        &#125;

    调用:

        val result1=mul(2)

        result1是一个函数

柯里化函数

偏函数

部分应用函数
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jackzhangqing.github.io/2023/09/02/%E5%8F%91%E6%96%87%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qzhang">
      <meta itemprop="description" content="痛点才是奋斗点~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qzhang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/02/%E5%8F%91%E6%96%87%E7%AB%A0/" class="post-title-link" itemprop="url">发文章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-02 16:11:49 / 修改时间：16:36:40" itemprop="dateCreated datePublished" datetime="2023-09-02T16:11:49+08:00">2023-09-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%9C%AF%E7%95%8C/" itemprop="url" rel="index"><span itemprop="name">学术界</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E6%9C%AF%E7%95%8C/%E8%AE%BA%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">论文-</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Nature-Science"><a href="#Nature-Science" class="headerlink" title="Nature Science"></a>Nature Science</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jackzhangqing.github.io/2023/09/02/Scala%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qzhang">
      <meta itemprop="description" content="痛点才是奋斗点~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qzhang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/02/Scala%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/" class="post-title-link" itemprop="url">Scala官方文档</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-02 15:59:17 / 修改时间：16:35:57" itemprop="dateCreated datePublished" datetime="2023-09-02T15:59:17+08:00">2023-09-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E4%B8%9A%E7%95%8C/" itemprop="url" rel="index"><span itemprop="name">工业界</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E4%B8%9A%E7%95%8C/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91Spark/" itemprop="url" rel="index"><span itemprop="name">大数据高级开发Spark</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>30k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>55 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><h3 id="1-什么是Scala"><a href="#1-什么是Scala" class="headerlink" title="1.什么是Scala"></a>1.什么是Scala</h3><p>Scala是一门现代的多范式语言，志在以简洁、优雅及类型安全的方式来表达常用的编程模型。它平滑地集成了面向对象和函数式语言的特性。</p>
<h3 id="2-Scala是面向对象编程语言"><a href="#2-Scala是面向对象编程语言" class="headerlink" title="2.Scala是面向对象编程语言"></a>2.Scala是面向对象编程语言</h3><p>鉴于一切值都是对象，可以说Scala是一门纯面向对象的语言。对象的类型和行为是由类和特质来描述的。类可以由子类化和一种灵活的、基于mixin的组合机制（它可作为多重继承的简单替代方案）来扩展。</p>
<h3 id="3-Scala是函数式编程语言"><a href="#3-Scala是函数式编程语言" class="headerlink" title="3.Scala是函数式编程语言"></a>3.Scala是函数式编程语言</h3><p>鉴于一切函数都是值，又可以说Scala是一门函数式语言。Scala为定义匿名函数提供了轻量级的语法，支持高阶函数，允许函数嵌套及柯里化。Scala的样例类和内置支持的模式匹配代数模型在许多函数式编程语言中都被使用。对于那些并非类的成员函数，单例对象提供了便捷的方式去组织它们。<br>    此外，通过对提取器的一般扩展，Scala的模式匹配概念使用了right-ignoring序列模式，自然地延伸到XML数据的处理。其中，for表达<br>式对于构建查询很有用。这些特性使得Scala成为开发web服务等程序的理想选择。</p>
<h3 id="4-Scala是静态类型的"><a href="#4-Scala是静态类型的" class="headerlink" title="4.Scala是静态类型的"></a>4.Scala是静态类型的</h3><p>Scala配备了一个拥有强大表达能力的类型系统，它可以静态地强制以安全、一致的方式使用抽象。典型来说，这个类型系统支持：<br>    1）泛型类<br>    2）型变注解<br>    3）上、下 类型边界<br>    4）作为对象成员的内部类和抽象类型<br>    5）复合类型<br>    6）显式类型的自我引用<br>    7）隐式参数和隐式转化<br>    8）多态方法<br>    9）类型推断让用户不需要标明额外的类型信息。这些特性结合起来为安全可重用的编程抽象以及类型安全的扩展提供了强大的基础。</p>
<h3 id="5-Scala是可扩展的"><a href="#5-Scala是可扩展的" class="headerlink" title="5.Scala是可扩展的"></a>5.Scala是可扩展的</h3><p>在实践中，特定领域应用的发展往往需要特定领域的语言扩展。Scala提供了一种语言机制的独特组合方式，使得可以方便地以库的形式添加新的语言结构。<br>    很多场景下，这些扩展可以不通过类似宏（macros）的元编程工具完成。例如：<br>    1）隐式类允许给已有的类型添加扩展方法。<br>    2）字符串插值可以让用户使用自定义的插值器进行扩展。</p>
<h3 id="6-Scala互操作"><a href="#6-Scala互操作" class="headerlink" title="6.Scala互操作"></a>6.Scala互操作</h3><p>Scala设计的目标是与流行的Java运行环境（JRE）进行良好的互操作，特别是与主流的面向对象编程语言——Java的互操作尽可能的平滑。Java的最新特性如函数接口（SAMs）、lambda表达式、注解及泛型类 在Scala中都有类似的实现。<br>    另外有些Java中并没有的特性，如缺省参数值和带名字的参数等，也是尽可能地向Java靠拢。Scala拥有类似Java的编译模型（独立编译、<br>动态类加载），且允许使用已有的成千上万的高质量类库。</p>
<h2 id="2-基础"><a href="#2-基础" class="headerlink" title="2.基础"></a>2.基础</h2><h3 id="2-1表达式-表达式是可计算语句。"><a href="#2-1表达式-表达式是可计算语句。" class="headerlink" title="2.1表达式:表达式是可计算语句。"></a>2.1表达式:表达式是可计算语句。</h3><pre><code>例如：1+1
常量: 
    1.使用val定义
    2.常量（values）不能重新被赋值。
    3.常量（values）的类型可以被推断,也可以显示地声明类型
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val x=1+1  或 val x:Int=1+1</span><br><span class="line">x=3 //编译不通过</span><br></pre></td></tr></table></figure>

变量: 使用var定义
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x=1+1 </span><br><span class="line">x=3</span><br><span class="line">println(x*x)</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="2-2块-组合几个表达式-并且用-包裹的称之为代码块。代码块中最后一个表达式的结果也是整个块的结果。"><a href="#2-2块-组合几个表达式-并且用-包裹的称之为代码块。代码块中最后一个表达式的结果也是整个块的结果。" class="headerlink" title="2.2块: 组合几个表达式,并且用{}包裹的称之为代码块。代码块中最后一个表达式的结果也是整个块的结果。"></a>2.2块: 组合几个表达式,并且用{}包裹的称之为代码块。代码块中最后一个表达式的结果也是整个块的结果。</h3><pre><code>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(&#123;</span><br><span class="line">			val x = 1 + 1</span><br><span class="line">			x + 1</span><br><span class="line">&#125;) // 3</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="2-3函数-函数是带参数的表达式。"><a href="#2-3函数-函数是带参数的表达式。" class="headerlink" title="2.3函数:函数是带参数的表达式。"></a>2.3函数:函数是带参数的表达式。</h3><pre><code>1.可以定义一个匿名函数（即无名称），返回给定的整数加一的结果：
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x:Int)=&gt;x+1</span><br></pre></td></tr></table></figure>
    =&gt;的左边是参数列表，右边是一个包含参数的表达式。
2.带名字的函数:
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val addOne=(x:Int)=&gt;x+1</span><br><span class="line">println(addOne(1))//2</span><br></pre></td></tr></table></figure>
3.多个参数的函数
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val add=(x:Int,y:Int)=&gt;x+y</span><br><span class="line">println(add(1,2))//3</span><br></pre></td></tr></table></figure>
4.无参数的函数
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val getTheAnswer=()=&gt;42</span><br><span class="line">      println(getTheAnswer())//42</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="2-4方法-方法看起来和行为与函数非常相似，但是它们之间有几个关键的区别。"><a href="#2-4方法-方法看起来和行为与函数非常相似，但是它们之间有几个关键的区别。" class="headerlink" title="2.4方法:方法看起来和行为与函数非常相似，但是它们之间有几个关键的区别。"></a>2.4方法:方法看起来和行为与函数非常相似，但是它们之间有几个关键的区别。</h3><pre><code>1.方法是用def关键字定义的。def后面是一个名称、参数列表、返回类型和方法体。
2.格式:
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     [修饰符] def methodName(name1:ArgsType1,name2:ArgsType2)[:retrunType]=&#123;</span><br><span class="line">      	//方法体</span><br><span class="line">   	&#125;</span><br><span class="line"></span><br><span class="line">   	def add(x: Int, y: Int): Int = x + y</span><br><span class="line">println(add(1, 2)) // 3</span><br></pre></td></tr></table></figure>
3.方法可以接受多个参数列表
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">     def addThenMultiply(x: Int, y: Int)(multiplier: Int): Int = (x + y) * multiplier</span><br><span class="line">println(addThenMultiply(1, 2)(3)) // 9</span><br></pre></td></tr></table></figure>
4.方法可以接受没有参数列表
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def name: String = System.getProperty(&quot;user.name&quot;)</span><br><span class="line">	println(&quot;Hello, &quot; + name + &quot;!&quot;)</span><br></pre></td></tr></table></figure>
5.还有其他一些区别，但是现在，可以将它们看作类似于函数的东西。
    方法也可以有多行表达式。
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def getSquareString(input: Double): String = &#123;</span><br><span class="line">			val square = input * input</span><br><span class="line">			square.toString</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    方法体的最后一个表达式就是方法的返回值。（Scala中也有一个return关键字，但是很少使用）
</code></pre>
<h3 id="2-5类-可以用class关键字来定义一个类，后面跟着它的名字和构造器。"><a href="#2-5类-可以用class关键字来定义一个类，后面跟着它的名字和构造器。" class="headerlink" title="2.5类:可以用class关键字来定义一个类，后面跟着它的名字和构造器。"></a>2.5类:可以用class关键字来定义一个类，后面跟着它的名字和构造器。</h3><pre><code>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Greeter(prefix: String, suffix: String) &#123;</span><br><span class="line">  def greet(name: String): Unit =</span><br><span class="line">    println(prefix + name + suffix)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    可以使用new关键字来构建一个类的实例。
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val greeter = new Greeter(&quot;Hello, &quot;, &quot;!&quot;)</span><br><span class="line">greeter.greet(&quot;Scala developer&quot;) // Hello, Scala developer!</span><br></pre></td></tr></table></figure>
    我们以后再深入讨论。
</code></pre>
<h3 id="2-6样例类-Scala有一种特殊的类叫做样例类（case-class）。默认情况下，样例类一般用于不可变对象，并且可作值比较。你可以使用case-class关键字来定义样例类。"><a href="#2-6样例类-Scala有一种特殊的类叫做样例类（case-class）。默认情况下，样例类一般用于不可变对象，并且可作值比较。你可以使用case-class关键字来定义样例类。" class="headerlink" title="2.6样例类:Scala有一种特殊的类叫做样例类（case class）。默认情况下，样例类一般用于不可变对象，并且可作值比较。你可以使用case class关键字来定义样例类。"></a>2.6样例类:Scala有一种特殊的类叫做样例类（case class）。默认情况下，样例类一般用于不可变对象，并且可作值比较。你可以使用case class关键字来定义样例类。</h3><pre><code>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">case class Point(x: Int, y: Int)</span><br><span class="line"></span><br><span class="line">   # 可以不使用new关键字来构建一个类的实例。</span><br><span class="line">val point = Point(1, 2)</span><br><span class="line">val anotherPoint = Point(1, 2)</span><br><span class="line">val yetAnotherPoint = Point(2, 2)</span><br><span class="line"></span><br><span class="line">   # 并且它们的值可以进行比较。</span><br><span class="line">if (point == anotherPoint) &#123;</span><br><span class="line">  println(point + &quot; and &quot; + anotherPoint + &quot; are the same.&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  println(point + &quot; and &quot; + anotherPoint + &quot; are different.&quot;)</span><br><span class="line">&#125; // Point(1,2) and Point(1,2) are the same.</span><br><span class="line">if (point == yetAnotherPoint) &#123;</span><br><span class="line">  println(point + &quot; and &quot; + yetAnotherPoint + &quot; are the same.&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  println(point + &quot; and &quot; + yetAnotherPoint + &quot; are different.&quot;)</span><br><span class="line">&#125; // Point(1,2) and Point(2,2) are different.</span><br></pre></td></tr></table></figure>
    我们以后再深入讨论。
</code></pre>
<h3 id="2-7对象-对象是它们自己定义的单实例，你可以把它看作它自己的类的单例。"><a href="#2-7对象-对象是它们自己定义的单实例，你可以把它看作它自己的类的单例。" class="headerlink" title="2.7对象:对象是它们自己定义的单实例，你可以把它看作它自己的类的单例。"></a>2.7对象:对象是它们自己定义的单实例，你可以把它看作它自己的类的单例。</h3><pre><code>    可以使用object关键字定义对象:
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	object IdFactory &#123;</span><br><span class="line">	  private var counter = 0</span><br><span class="line">	  def create(): Int = &#123;</span><br><span class="line">	    counter += 1</span><br><span class="line">	    counter</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">可以通过引用对象的名称访问对象。</span><br><span class="line">val newId: Int = IdFactory.create()</span><br><span class="line">println(newId) // 1</span><br><span class="line">val newerId: Int = IdFactory.create()</span><br><span class="line">println(newerId) // 2</span><br></pre></td></tr></table></figure>
    我们以后再深入讨论。
</code></pre>
<h3 id="2-8特质-特质是包含某些字段和方法的类型。可以组合多个特质。"><a href="#2-8特质-特质是包含某些字段和方法的类型。可以组合多个特质。" class="headerlink" title="2.8特质:特质是包含某些字段和方法的类型。可以组合多个特质。"></a>2.8特质:特质是包含某些字段和方法的类型。可以组合多个特质。</h3><pre><code>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">可以使用trait关键字定义特质:</span><br><span class="line">	trait Greeter &#123;</span><br><span class="line">	  def greet(name: String): Unit</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">特质可以有默认的实现:</span><br><span class="line">	trait Greeter &#123;</span><br><span class="line">	  def greet(name: String): Unit =</span><br><span class="line">	    println(&quot;Hello, &quot; + name + &quot;!&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">可以使用extends关键字来继承特质，使用override关键字来覆盖默认的实现。</span><br><span class="line">	class DefaultGreeter extends Greeter</span><br><span class="line">	class CustomizableGreeter(prefix: String, postfix: String) extends Greeter &#123;</span><br><span class="line">	  override def greet(name: String): Unit = &#123;</span><br><span class="line">	    println(prefix + name + postfix)</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	val greeter = new DefaultGreeter()</span><br><span class="line">	greeter.greet(&quot;Scala developer&quot;) // Hello, Scala develop</span><br><span class="line">	val customGreeter = new CustomizableGreeter(&quot;How are you, &quot;, &quot;?&quot;)</span><br><span class="line">	customGreeter.greet(&quot;Scala developer&quot;) // How are you, Scala developer?</span><br></pre></td></tr></table></figure>
    在这里，DefaultGreeter只继承了一个特征，但它可以继承多个特征。

    我们以后将深入研究特征。
</code></pre>
<h3 id="2-9主方法-主方法是一个程序的入口点。JVM要求一个名为main的主方法，接受一个字符串数组的参数。"><a href="#2-9主方法-主方法是一个程序的入口点。JVM要求一个名为main的主方法，接受一个字符串数组的参数。" class="headerlink" title="2.9主方法:主方法是一个程序的入口点。JVM要求一个名为main的主方法，接受一个字符串数组的参数。"></a>2.9主方法:主方法是一个程序的入口点。JVM要求一个名为main的主方法，接受一个字符串数组的参数。</h3><pre><code>    使用对象，可以将主方法定义如下：
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object Main &#123;</span><br><span class="line">  def main(args: Array[String]): Unit =</span><br><span class="line">    println(&quot;Hello, Scala developer!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="3-统一类型"><a href="#3-统一类型" class="headerlink" title="3.统一类型"></a>3.统一类型</h2><pre><code>在Scala中，所有的值都有类型，包括数值和函数。下图阐述了类型层次结构的一个子集。
        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Any （顶级类型）</span><br><span class="line">AnyVal 		AnyRef(java.lang.Object)</span><br><span class="line">  ^				List</span><br><span class="line">  |				Option</span><br><span class="line">Double			YourClass</span><br><span class="line">Dloat				^</span><br><span class="line">Long  				|</span><br><span class="line">Int 				|</span><br><span class="line">Short 				|</span><br><span class="line">Byte 				|</span><br><span class="line">Boolean 			|</span><br><span class="line">Char 				Null</span><br><span class="line">Unit				^</span><br><span class="line">  ^              	|</span><br><span class="line">  |					|</span><br><span class="line">Nothing（底部类型）</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="3-1Scala类型层级"><a href="#3-1Scala类型层级" class="headerlink" title="3.1Scala类型层级"></a>3.1Scala类型层级</h3><p>Any是所有类型的超类型，也称为顶级类型。它定义了一些通用的方法如equals、hashCode和toString。Any有两个直接子类：AnyVal和<br>AnyRef。<br>    AnyVal代表值类型。有9个预定义的非空的值类型分别是：Double、Float、Long、Int、Short、Byte、Char、Unit和Boolean。Unit是<br>不带任何意义的值类型，它仅有一个实例可以像这样声明：()。所有的函数必须有返回，所以说有时候Unit也是有用的返回类型。<br>    AnyRef代表引用类型。所有非值类型都被定义为引用类型。在Scala中，每个用户自定义的类型都是AnyRef的子类型。如果Scala被应用在<br>Java的运行环境中，AnyRef相当于java.lang.Object。<br>    值类的空间是平坦的；所有的值类都是scala.AnyVal的子类型，但是它们不是其他类的子类。但是不同的值类类型之间可以隐式地互相转<br>换。例如，需要的时候，类scala.Int的实例可以通过隐式转换放宽到类scala.Long的实例；Int支持min、max、until、to、abs等操作，其实是从类Int隐式转换到scala.runtime.RichInt的。<br>    AnyRef是引用类型。所有非值类型都定义为引用类型.它其实是Java平台上java.lang.Object类的别名。因此Java里写的类和Scala里写<br>的都继承自AnyRef。<br>    Scala类与Java类的不同在于它们还继承自一个名为ScalaObject的特别记号特质。是想要通过ScalaObject包含的Scala编译器定义和实<br>现的方法让Scala程序的执行更高效。</p>
<pre><code>类型转化.
下面是一个示例，说明了字符串、整型、布尔值和函数都是对象，这一点和其他对象一样：
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   val list: List[Any] = List(</span><br><span class="line">	  &quot;a string&quot;,</span><br><span class="line">	  732,  // an integer</span><br><span class="line">	  &#x27;c&#x27;,  // a character</span><br><span class="line">	  true, // a boolean value</span><br><span class="line">	  () =&gt; &quot;an anonymous function returning a string&quot;</span><br><span class="line">	)</span><br><span class="line">list.foreach(element =&gt; println(element))</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="3-2类型转化"><a href="#3-2类型转化" class="headerlink" title="3.2类型转化"></a>3.2类型转化</h3><pre><code>    值类型可以按照下面的方向进行转换： 

    Byte-&gt;Short-&gt;Int-&gt;Long-&gt;Float-&gt;Double

                  ^

                  |

                 Char

    例1:

        val x: Long = 987654321

        val y: Float = x  // 9.8765434E8 (note that some precision is lost in this case)

        val face: Char = &#39;☺&#39;

        val number: Int = face  // 9786

    例2:转换是单向，下面这样写将不会通过编译。

        val x: Long = 987654321

        val y: Float = x  // 9.8765434E8

        val z: Long = y  // Does not conform
</code></pre>
<h3 id="3-3Nothing和Null"><a href="#3-3Nothing和Null" class="headerlink" title="3.3Nothing和Null"></a>3.3Nothing和Null</h3><pre><code>    scala.Null和scala.Nothing是用统一的方式处理Scala面向对象类型系统的某些&quot;边界情况&quot;的特殊类型。

    Nothing是所有类型的子类型，也称为底层类型。没有一个值是Nothing类型的。它的用途之一是给出非正常终止的信号，如抛出异常、程序退出或者一个无限循环（可以理解为它是一个不对值进行定义的表达式的类型，或者是一个不能正常返回的方法）。

    Null是所有引用类型的子类型（即AnyRef的任意子类型）。它有一个单例值由关键字null所定义。Null主要是使得Scala满足和其他JVM语言的互操作性，但是几乎不应该在Scala代码中使用。我们将在后面的章节中介绍null的替代方案。

    例1:

        def error(message: String): Nothing = throw new RuntimeException(message)

    例2:

        def divide(x: Int, y: Int): Int = if(y != 0) x / y else error(&quot;Can&#39;t divide by zero&quot;)
</code></pre>
<h2 id="4-类"><a href="#4-类" class="headerlink" title="4.类"></a>4.类</h2><pre><code>Scala中的类是用于创建对象的蓝图，其中包含了方法、常量、变量、类型、对象、特质、类，这些统称为成员。类型、对象和特质将在后面的文章中介绍。
</code></pre>
<h3 id="4-1定义类"><a href="#4-1定义类" class="headerlink" title="4.1定义类"></a>4.1定义类</h3><h4 id="4-1-1格式：class-类名-private-package-this-主构造器参数列表-extends-类-特质-with-特质1-with-特质2"><a href="#4-1-1格式：class-类名-private-package-this-主构造器参数列表-extends-类-特质-with-特质1-with-特质2" class="headerlink" title="4.1.1格式：class 类名 private[package&#x2F;this] (主构造器参数列表) extends 类&#x2F;特质 with 特质1 with 特质2{}"></a>4.1.1格式：class 类名 private[package&#x2F;this] (主构造器参数列表) extends 类&#x2F;特质 with 特质1 with 特质2{}</h4><pre><code>    eg: class Student(name:String,age:Int) extends Father with T1 with T2&#123;

      //属性

      //方法

      //主构造器中的代码

      println(&quot;.....&quot;)

      def this()=&#123;

        //.......

      &#125;

    &#125;
</code></pre>
<h4 id="4-1-2案例："><a href="#4-1-2案例：" class="headerlink" title="4.1.2案例："></a>4.1.2案例：</h4><pre><code> 	 例1:一个最简的类的定义就是关键字class+标识符，类名必须是大写。

    	class User

        val user1 = new User

      例2:关键字new被用于创建类的实例。User由于没有定义任何构造器，因而只有一个不带任何参数的默认构造器。然而，你通常需要一个构造器和类体。下面是类定义的一个例子：

        class Point(var x: Int, var y: Int) &#123;

          def move(dx: Int, dy: Int): Unit = &#123;

            x = x + dx

            y = y + dy

          &#125;

          override def toString: String =

            s&quot;($x, $y)&quot;

        &#125;

        val point1 = new Point(2, 3)

        point1.x  // 2

        println(point1)  // prints (2, 3)
</code></pre>
<h3 id="4-2构造器"><a href="#4-2构造器" class="headerlink" title="4.2构造器"></a>4.2构造器</h3><h4 id="4-2-1-概念"><a href="#4-2-1-概念" class="headerlink" title="4.2.1:概念:"></a>4.2.1:概念:</h4><pre><code>        主构造器 : 与类的定义交织在一起

          辅助构造器 :  

            1.通过方法名this重载构造器 

            2.辅助构造器的第一行代码必须是调用主构造器或者调用其他已经定义好的辅助构造器
</code></pre>
<h4 id="4-2-2-主构造器参数列表"><a href="#4-2-2-主构造器参数列表" class="headerlink" title="4.2.2 主构造器参数列表"></a>4.2.2 主构造器参数列表</h4><pre><code>        形式：

          1.参数名:类型  

          2.var 参数名:类型

          3.val 参数名:类型

          4.private val/var 参数名:类型

          5.@BeanProperty val/var 参数名:类型

        总结：

          1.当参数没有被修饰，且在类中没有使用该参数，该参数什么都不会生成。

          2.当参数被val修饰时，会生成private修饰的字段/属性，以及提供一个名字为参数名的公有取值方法。

          3.当参数被var修饰时，会生成private修饰的字段/属性，以及提供一个名字为参数名的公有取值方法和一个名字为参数名_=的公有赋值方法。

          4.与2,3生成的字段以及方法个数一致，不同在于生成的方法时私有的。

          5.@BeanProperty 会生成javaBean版本的set/get方法
</code></pre>
<h4 id="4-2-3-案例"><a href="#4-2-3-案例" class="headerlink" title="4.2.3:案例:"></a>4.2.3:案例:</h4><pre><code>     例1:构造器可以通过提供一个默认值来拥有可选参数：

        class Point(var x: Int = 0, var y: Int = 0)

        val origin = new Point  // x and y are both set to 0

        val point1 = new Point(1)

        println(point1.x)  // prints 1

     例2:在这个版本的Point类中，x和y拥有默认值0所以没有必传参数。然而，因为构造器是从左往右读取参数，所以如果仅仅要传个y的值，你需要带名传参。

        class Point(var x: Int = 0, var y: Int = 0)

        val point2 = new Point(y=2)

        println(point2.y)  // prints 2

    这样的做法在实践中有利于使得表达明确无误。
</code></pre>
<h3 id="4-3私有成员和Getter-Setter语法"><a href="#4-3私有成员和Getter-Setter语法" class="headerlink" title="4.3私有成员和Getter&#x2F;Setter语法"></a>4.3私有成员和Getter&#x2F;Setter语法</h3><pre><code>    成员默认是公有（public）的。使用private访问修饰符可以在函数外部隐藏它们。

    例1:

        class Point &#123;

          private var _x = 0

          private var _y = 0

          private val bound = 100

          def x = _x

          def x_= (newValue: Int): Unit = &#123;

            if (newValue &lt; bound) _x = newValue else printWarning

          &#125;

          def y = _y

          def y_= (newValue: Int): Unit = &#123;

            if (newValue &lt; bound) _y = newValue else printWarning

          &#125;

          private def printWarning = println(&quot;WARNING: Out of bounds&quot;)

        &#125;

        val point1 = new Point

        point1.x = 99

        point1.y = 101 // prints the warning

        在这个版本的Point类中，数据存在私有变量_x和_y中。def x和def y方法用于访问私有数据。def x_=和def y_=是为了验证和给_x和_y赋值。注意下对于setter方法的特殊语法：这个方法在getter方法的后面加上_=，后面跟着参数。

    例2:主构造方法中带有val和var的参数时公有的。然而由于val是不可变的，所以不能像下面这样去使用。

        class Point(val x: Int, val y: Int)

        val point = new Point(1, 2)

        point.x = 3  // &lt;-- does not compile

    例3:不带val或var的参数是私有的，仅在类中可见。

        class Point(x: Int, y: Int)

        val point = new Point(1, 2)

        point.x  // &lt;-- does not compile
</code></pre>
<h2 id="5-特质"><a href="#5-特质" class="headerlink" title="5.特质"></a>5.特质</h2><pre><code>特质 (Traits) 用于在类 (Class)之间共享程序接口 (Interface)和字段 (Fields)。 它们类似于Java 8的接口。 类和对象 (Objects)可以扩展特质，但是特质不能被实例化，因此特质没有参数。
</code></pre>
<h3 id="5-1定义特质"><a href="#5-1定义特质" class="headerlink" title="5.1定义特质:"></a>5.1定义特质:</h3><pre><code>    格式: trait 特质名 extends 类/特质 with 特质1 &#123;&#125;

    总结: 

        1.可以包含具体方法/属性

        2.可以包含抽象方法/属性

        3.特质 可以 混入 类/对象/特质/实例(对象)

    案例:

    	例1:最简化的特质就是关键字trait+标识符：

    		trait HairColor

    	例2:特征作为泛型类型和抽象方法非常有用。

    		trait Iterator[A] &#123;

              def hasNext: Boolean

              def next(): A

            &#125;

        扩展 trait Iterator [A] 需要一个类型 A 和实现方法hasNext和next。
</code></pre>
<h3 id="5-2使用特质"><a href="#5-2使用特质" class="headerlink" title="5.2使用特质:"></a>5.2使用特质:</h3><pre><code>    使用 extends 关键字来扩展特征。然后使用 override 关键字来实现trait里面的任何抽象成员：

        trait Iterator[A] &#123;

          def hasNext: Boolean

          def next(): A

        &#125;

        class IntIterator(to: Int) extends Iterator[Int] &#123;

          private var current = 0

          override def hasNext: Boolean = current &lt; to

          override def next(): Int =  &#123;

            if (hasNext) &#123;

              val t = current

              current += 1

              t

            &#125; else 0

          &#125;

        &#125;

        val iterator = new IntIterator(10)

        iterator.next()  // returns 0

        iterator.next()  // returns 1

    这个类 IntIterator 将参数 to 作为上限。它扩展了 Iterator [Int]，这意味着方法 next 必须返回一个Int。
</code></pre>
<h3 id="5-3子类型"><a href="#5-3子类型" class="headerlink" title="5.3子类型:"></a>5.3子类型:</h3><pre><code>    凡是需要特质的地方，都可以由该特质的子类型来替换。

    import scala.collection.mutable.ArrayBuffer

    trait Pet &#123;

      val name: String

    &#125;

    class Cat(val name: String) extends Pet

    class Dog(val name: String) extends Pet

    val dog = new Dog(&quot;Harry&quot;)

    val cat = new Cat(&quot;Sally&quot;)

    val animals = ArrayBuffer.empty[Pet]

    animals.append(dog)

    animals.append(cat)

    animals.foreach(pet =&gt; println(pet.name))  // Prints Harry Sally

    在这里 trait Pet 有一个抽象字段 name ，name 由Cat和Dog的构造函数中实现。最后一行，我们能调用pet.name的前提是它必须在特质Pet的子类型中得到了实现。
</code></pre>
<h2 id="6-元祖"><a href="#6-元祖" class="headerlink" title="6.元祖"></a>6.元祖</h2><pre><code>在 Scala 中，元组是一个可以容纳不同类型元素的类。 元组是不可变的。

当我们需要从函数返回多个值时，元组会派上用场。

元组可以创建如下：

    val ingredient = (&quot;Sugar&quot; , 25):Tuple2[String, Int]

这将创建一个包含一个 String 元素和一个 Int 元素的元组。

Scala 中的元组包含一系列类：Tuple2，Tuple3等，直到 Tuple22。 因此，当我们创建一个包含 n 个元素（n 位于 2 和 22 之间）的元组时，Scala 基本上就是从上述的一组类中实例化 一个相对应的类，使用组成元素的类型进行参数化。 上例中，ingredient 的类型为 Tuple2[String, Int]。
</code></pre>
<h3 id="6-1访问元素"><a href="#6-1访问元素" class="headerlink" title="6.1访问元素"></a>6.1访问元素</h3><pre><code>    使用下划线语法来访问元组中的元素。 ‘tuple._n’ 取出了第 n 个元素（假设有足够多元素）。

    println(ingredient._1) // Sugar

    println(ingredient._2) // 25
</code></pre>
<h3 id="6-2解构元组数据"><a href="#6-2解构元组数据" class="headerlink" title="6.2解构元组数据"></a>6.2解构元组数据</h3><pre><code>    Scala 元组也支持解构。

    val (name, quantity) = ingredient

    println(name) // Sugar

    println(quantity) // 25

    元组解构也可用于模式匹配。

    val planetDistanceFromSun = List((&quot;Mercury&quot;, 57.9), (&quot;Venus&quot;, 108.2), (&quot;Earth&quot;, 149.6 ), (&quot;Mars&quot;, 227.9), (&quot;Jupiter&quot;, 778.3))

    planetDistanceFromSun.foreach&#123; tuple =&gt; &#123;

      tuple match &#123;

          case (&quot;Mercury&quot;, distance) =&gt; println(s&quot;Mercury is $distance millions km far from Sun&quot;)

          case p if(p._1 == &quot;Venus&quot;) =&gt; println(s&quot;Venus is $&#123;p._2&#125; millions km far from Sun&quot;)

          case p if(p._1 == &quot;Earth&quot;) =&gt; println(s&quot;Blue planet is $&#123;p._2&#125; millions km far from Sun&quot;)

          case _ =&gt; println(&quot;Too far....&quot;)

        &#125;

      &#125;

    &#125;

    或者，在 ‘for’ 表达式中。

    val numPairs = List((2, 5), (3, -7), (20, 56))

    for ((a, b) &lt;- numPairs) &#123;

      println(a * b)

    &#125;

类型 Unit 的值 () 在概念上与类型 Tuple0 的值 () 相同。 Tuple0 只能有一个值，因为它没有元素。

用户有时可能在元组和 case 类之间难以选择。 通常，如果元素具有更多含义，则首选 case 类。
</code></pre>
<h2 id="7-通过混入（MIXIN）来组合类"><a href="#7-通过混入（MIXIN）来组合类" class="headerlink" title="7.通过混入（MIXIN）来组合类"></a>7.通过混入（MIXIN）来组合类</h2><pre><code>当某个特质被用于组合类时，被称为混入。

    abstract class A &#123;

      val message: String

    &#125;

    class B extends A &#123;

      val message = &quot;I&#39;m an instance of class B&quot;

    &#125;

    trait C extends A &#123;

      def loudMessage = message.toUpperCase()

    &#125;

    class D extends B with C

    val d = new D

    println(d.message)  // I&#39;m an instance of class B

    println(d.loudMessage)  // I&#39;M AN INSTANCE OF CLASS B

类D有一个父类B和一个混入C。一个类只能有一个父类但是可以有多个混入（分别使用关键字extend和with）。混入和某个父类可能有相同的父类。

现在，让我们看一个更有趣的例子，其中使用了抽象类：

    abstract class AbsIterator &#123;

      type T

      def hasNext: Boolean

      def next(): T

    &#125;

该类中有一个抽象的类型T和标准的迭代器方法。

接下来，我们将实现一个具体的类（所有的抽象成员T、hasNext和next都会被实现）：

    class StringIterator(s: String) extends AbsIterator &#123;

      type T = Char

      private var i = 0

      def hasNext = i &lt; s.length

      def next() = &#123;

        val ch = s charAt i

        i += 1

        ch

      &#125;

    &#125;

StringIterator带有一个String类型参数的构造器，可用于对字符串进行迭代。（例如查看一个字符串是否包含某个字符）：

现在我们创建一个特质，也继承于AbsIterator。

    trait RichIterator extends AbsIterator &#123;

      def foreach(f: T =&gt; Unit): Unit = while (hasNext) f(next())

    &#125;

该特质实现了foreach方法——只要还有元素可以迭代（while (hasNext)），就会一直对下个元素(next()) 调用传入的函数f: T =&gt; Unit。因为RichIterator是个特质，可以不必实现AbsIterator中的抽象成员。

下面我们要把StringIterator和RichIterator 中的功能组合成一个类。

    object StringIteratorTest extends App &#123;

      class RichStringIter extends StringIterator(&quot;Scala&quot;) with RichIterator

      val richStringIter = new RichStringIter

      richStringIter foreach println

    &#125;

新的类RichStringIter有一个父类StringIterator和一个混入RichIterator。如果是单一继承，我们将不会达到这样的灵活性。
</code></pre>
<h2 id="8-高阶函数"><a href="#8-高阶函数" class="headerlink" title="8.高阶函数"></a>8.高阶函数</h2><pre><code>高阶函数是指使用其他函数作为参数、或者返回一个函数作为结果的函数。在Scala中函数是&quot;一等公民&quot;，所以允许定义高阶函数。这里的术语可能有点让人困惑，我们约定，使用函数值作为参数，或者返回值为函数值的&quot;函数&quot;和&quot;方法&quot;，均称之为&quot;高阶函数&quot;。

最常见的一个例子是Scala集合类（collections）的高阶函数map

    val salaries = Seq(20000, 70000, 40000)

    val doubleSalary = (x: Int) =&gt; x * 2

    val newSalaries = salaries.map(doubleSalary) // List(40000, 140000, 80000)

函数doubleSalary有一个整型参数x，返回x * 2。一般来说，在=&gt;左边的元组是函数的参数列表，而右边表达式的值则为函数的返回值。在第3行，函数doubleSalary被应用在列表salaries中的每一个元素。

为了简化压缩代码，我们可以使用匿名函数，直接作为参数传递给map:

    val salaries = Seq(20000, 70000, 40000)

    val newSalaries = salaries.map(x =&gt; x * 2) // List(40000, 140000, 80000)

注意在上述示例中x没有被显式声明为Int类型，这是因为编译器能够根据map函数期望的类型推断出x的类型。对于上述代码，一种更惯用的写法为：

    val salaries = Seq(20000, 70000, 40000)

    val newSalaries = salaries.map(_ * 2)

既然Scala编译器已经知道了参数的类型（一个单独的Int），可以只给出函数的右半部分，不过需要使用_代替参数名（在上一个例子中是x）
</code></pre>
<h3 id="1-强制转换方法为函数"><a href="#1-强制转换方法为函数" class="headerlink" title="1.强制转换方法为函数"></a>1.强制转换方法为函数</h3><pre><code>    可以传入一个对象方法作为高阶函数的参数，这是因为Scala编译器会将方法强制转换为一个函数。

        case class WeeklyWeatherForecast(temperatures: Seq[Double]) &#123;

          private def convertCtoF(temp: Double) = temp * 1.8 + 32

          def forecastInFahrenheit: Seq[Double] = temperatures.map(convertCtoF) // &lt;-- passing the method convertCtoF

        &#125;

    在这个例子中，方法convertCtoF被传入forecastInFahrenheit。这是可以的，因为编译器强制将方法convertCtoF转成了函数x =&gt; convertCtoF(x) （注: x是编译器生成的变量名，保证在其作用域是唯一的）。
</code></pre>
<h3 id="2-接收函数作为参数的函数"><a href="#2-接收函数作为参数的函数" class="headerlink" title="2.接收函数作为参数的函数"></a>2.接收函数作为参数的函数</h3><pre><code>    使用高阶函数的一个原因是减少冗余的代码。比方说需要写几个方法以通过不同方式来提升员工工资，若不使用高阶函数，代码可能像这样：

        object SalaryRaiser &#123;

          def smallPromotion(salaries: List[Double]): List[Double] =

            salaries.map(salary =&gt; salary * 1.1)

          def greatPromotion(salaries: List[Double]): List[Double] =

            salaries.map(salary =&gt; salary * math.log(salary))

          def hugePromotion(salaries: List[Double]): List[Double] =

            salaries.map(salary =&gt; salary * salary)

        &#125;

    注意这三个方法的差异仅仅是提升的比例不同，为了简化代码，其实可以把重复的代码提到一个高阶函数中：

        object SalaryRaiser &#123;

          private def promotion(salaries: List[Double], promotionFunction: Double =&gt; Double): List[Double] =

            salaries.map(promotionFunction)

          def smallPromotion(salaries: List[Double]): List[Double] =

            promotion(salaries, salary =&gt; salary * 1.1)

          def bigPromotion(salaries: List[Double]): List[Double] =

            promotion(salaries, salary =&gt; salary * math.log(salary))

          def hugePromotion(salaries: List[Double]): List[Double] =

            promotion(salaries, salary =&gt; salary * salary)

        &#125;

    新的方法promotion有两个参数，薪资列表和一个类型为Double =&gt; Double的函数（参数和返回值类型均为Double），返回薪资提升的结果。
</code></pre>
<h3 id="3-返回函数的函数"><a href="#3-返回函数的函数" class="headerlink" title="3.返回函数的函数"></a>3.返回函数的函数</h3><pre><code>    有一些情况你希望生成一个函数， 比如：

        def urlBuilder(ssl: Boolean, domainName: String): (String, String) =&gt; String = &#123;

          val schema = if (ssl) &quot;https://&quot; else &quot;http://&quot;

          (endpoint: String, query: String) =&gt; s&quot;$schema$domainName/$endpoint?$query&quot;

        &#125;

        val domainName = &quot;www.example.com&quot;

        def getURL = urlBuilder(ssl=true, domainName)

        val endpoint = &quot;users&quot;

        val query = &quot;id=1&quot;

        val url = getURL(endpoint, query) // &quot;https://www.example.com/users?id=1&quot;: String

    注意urlBuilder的返回类型是(String, String) =&gt; String，这意味着返回的匿名函数有两个String参数，返回一个String。在这个例子中，返回的匿名函数是(endpoint: String, query: String) =&gt; s&quot;https://www.example.com/$endpoint?$query&quot;。
</code></pre>
<h2 id="9-嵌套方法"><a href="#9-嵌套方法" class="headerlink" title="9.嵌套方法"></a>9.嵌套方法</h2><pre><code>在Scala中可以嵌套定义方法。例如以下对象提供了一个factorial方法来计算给定数值的阶乘：

     def factorial(x: Int): Int = &#123;

        def fact(x: Int, accumulator: Int): Int = &#123;

          if (x &lt;= 1) accumulator

          else fact(x - 1, x * accumulator)

        &#125;  

        fact(x, 1)

     &#125;

     println(&quot;Factorial of 2: &quot; + factorial(2))

     println(&quot;Factorial of 3: &quot; + factorial(3))

程序的输出为:

    Factorial of 2: 2

    Factorial of 3: 6
</code></pre>
<h2 id="10-多参数列表（柯里化）"><a href="#10-多参数列表（柯里化）" class="headerlink" title="10.多参数列表（柯里化）"></a>10.多参数列表（柯里化）</h2><pre><code>方法可以定义多个参数列表，当使用较少的参数列表调用多参数列表的方法时，会产生一个新的函数，该函数接收剩余的参数列表作为其参数。这被称为柯里化。

下面是一个例子，在Scala集合中定义的特质Traversable：

    def foldLeft[B](z: B)(op: (B, A) =&gt; B): B

foldLeft从左到右，以此将一个二元运算op应用到初始值z和该迭代器（traversable)的所有元素上。以下是该函数的一个用例：

从初值0开始, 这里 foldLeft 将函数 (m, n) =&gt; m + n 依次应用到列表中的每一个元素和之前累积的值上。

    val numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

    val res = numbers.foldLeft(0)((m, n) =&gt; m + n)

    print(res) // 55

多参数列表有更复杂的调用语法，因此应该谨慎使用，建议的使用场景包括：

    单一的函数参数

        在某些情况下存在单一的函数参数时，例如上述例子foldLeft中的op，多参数列表可以使得传递匿名函数作为参数的语法更为简洁。如果不使用多参数列表，代码可能像这样：

            numbers.foldLeft(0, &#123;(m: Int, n: Int) =&gt; m + n&#125;)

        注意使用多参数列表时，我们还可以利用Scala的类型推断来让代码更加简洁（如下所示），而如果没有多参数列表，这是不可能的。

            numbers.foldLeft(0)(_ + _)

        像上述语句这样，我们可以给定多参数列表的一部分参数列表（如上述的z）来形成一个新的函数（partially applied function），达到复用的目的，如下所示：

            val numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

            val numberFunc = numbers.foldLeft(List[Int]())_

            val squares = numberFunc((xs, x) =&gt; xs:+ x*x)

            print(squares.toString()) // List(1, 4, 9, 16, 25, 36, 49, 64, 81, 100)

            val cubes = numberFunc((xs, x) =&gt; xs:+ x*x*x)

            print(cubes.toString())  // List(1, 8, 27, 64, 125, 216, 343, 512, 729, 1000)

        最后，foldLeft 和 foldRight 可以按以下任意一种形式使用，

            val numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

            numbers.foldLeft(0)((sum, item) =&gt; sum + item) // Generic Form

            numbers.foldRight(0)((sum, item) =&gt; sum + item) // Generic Form

            numbers.foldLeft(0)(_+_) // Curried Form

            numbers.foldRight(0)(_+_) // Curried Form

            (0 /: numbers)(_+_) // Used in place of foldLeft

            (numbers :\ 0)(_+_) // Used in place of foldRight

    隐式（IMPLICIT）参数

        如果要指定参数列表中的某些参数为隐式（implicit），应该使用多参数列表。例如：

        def execute(arg: Int)(implicit ec: ExecutionContext) = ???
</code></pre>
<h2 id="11-单例对象"><a href="#11-单例对象" class="headerlink" title="11.单例对象"></a>11.单例对象</h2><pre><code>单例对象是一种特殊的类，有且只有一个实例。和惰性变量一样，单例对象是延迟创建的，当它第一次被使用时创建。

当对象定义于顶层时(即没有包含在其他类中)，单例对象只有一个实例。

当对象定义在一个类或方法中时，单例对象表现得和惰性变量一样。
</code></pre>
<h3 id="1-定义一个单例对象"><a href="#1-定义一个单例对象" class="headerlink" title="1.定义一个单例对象"></a>1.定义一个单例对象</h3><pre><code>    一个单例对象是就是一个值。单例对象的定义方式很像类，但是使用关键字 object：

        object Box

    下面例子中的单例对象包含一个方法：

        package logging

        object Logger &#123;

          def info(message: String): Unit = println(s&quot;INFO: $message&quot;)

        &#125;

    方法 info 可以在程序中的任何地方被引用。像这样创建功能性方法是单例对象的一种常见用法。

    下面让我们来看看如何在另外一个包中使用 info 方法：

        import logging.Logger.info

        class Project(name: String, daysToComplete: Int)

        class Test &#123;

          val project1 = new Project(&quot;TPS Reports&quot;, 1)

          val project2 = new Project(&quot;Website redesign&quot;, 5)

          info(&quot;Created projects&quot;)  // Prints &quot;INFO: Created projects&quot;

        &#125;

    因为 import 语句 import logging.Logger.info，方法 info 在此处是可见的。

    import语句要求被导入的标识具有一个&quot;稳定路径&quot;，一个单例对象由于全局唯一，所以具有稳定路径。

    注意：如果一个 object 没定义在顶层而是定义在另一个类或者单例对象中，那么这个单例对象和其他类普通成员一样是&quot;路径相关的&quot;。这意味着有两种行为，class Milk 和 class OrangeJuice，一个类成员 object NutritionInfo &quot;依赖&quot;于包装它的实例，要么是牛奶要么是橙汁。 milk.NutritionInfo 则完全不同于oj.NutritionInfo。
</code></pre>
<h3 id="2-伴生对象"><a href="#2-伴生对象" class="headerlink" title="2.伴生对象"></a>2.伴生对象</h3><pre><code>    当一个单例对象和某个类共享一个名称时，这个单例对象称为 伴生对象。 同理，这个类被称为是这个单例对象的伴生类。类和它的伴生对象可以互相访问其私有成员。使用伴生对象来定义那些在伴生类中不依赖于实例化对象而存在的成员变量或者方法。

        import scala.math._

        case class Circle(radius: Double) &#123;

          import Circle._

          def area: Double = calculateArea(radius)

        &#125;

        object Circle &#123;

          private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)

        &#125;

        val circle1 = new Circle(5.0)

        circle1.area

    这里的 class Circle 有一个成员 area 是和具体的实例化对象相关的，单例对象 object Circle 包含一个方法 calculateArea ，它在每一个实例化对象中都是可见的。

    伴生对象也可以包含工厂方法：

        class Email(val username: String, val domainName: String)

        object Email &#123;

          def fromString(emailString: String): Option[Email] = &#123;

            emailString.split(&#39;@&#39;) match &#123;

              case Array(a, b) =&gt; Some(new Email(a, b))

              case _ =&gt; None

            &#125;

          &#125;

        &#125;

        val scalaCenterEmail = Email.fromString(&quot;scala.center@epfl.ch&quot;)

        scalaCenterEmail match &#123;

          case Some(email) =&gt; println(

            s&quot;&quot;&quot;Registered an email

               |Username: $&#123;email.username&#125;

               |Domain name: $&#123;email.domainName&#125;

             &quot;&quot;&quot;)

          case None =&gt; println(&quot;Error: could not parse email&quot;)

        &#125;

    伴生对象 object Email 包含有一个工厂方法 fromString 用来根据一个 String 创建 Email 实例。在这里我们返回的是 Option[Email] 以防有语法分析错误。

    注意：类和它的伴生对象必须定义在同一个源文件里。如果需要在 REPL 里定义类和其伴生对象，需要将它们定义在同一行或者进入 :paste 模式。
</code></pre>
<h3 id="3-Java-程序员的注意事项"><a href="#3-Java-程序员的注意事项" class="headerlink" title="3.Java 程序员的注意事项"></a>3.Java 程序员的注意事项</h3><pre><code>    在 Java 中 static 成员对应于 Scala 中的伴生对象的普通成员。

    在 Java 代码中调用伴生对象时，伴生对象的成员会被定义成伴生类中的 static 成员。这称为 静态转发。这种行为发生在当你自己没有定义一个伴生类时。
</code></pre>
<h2 id="12-正则表达式"><a href="#12-正则表达式" class="headerlink" title="12.正则表达式"></a>12.正则表达式</h2><pre><code>正则表达式是一类特殊的字符串，可以用来在数据中寻找特定模式。 任何字符串都可以通过调用 .r 方法来转换成正则表达式。

    import scala.util.matching.Regex

    val numberPattern: Regex = &quot;[0-9]&quot;.r

    numberPattern.findFirstMatchIn(&quot;awesomepassword&quot;) match &#123;

      case Some(_) =&gt; println(&quot;Password OK&quot;)

      case None =&gt; println(&quot;Password must contain a number&quot;)

    &#125;

在上例中，常量 numberPattern 是一个 Regex 类型的实例（正则表达式），这里用来确保密码中含有一个数字。

你也可以用圆括号括起多个正则表达式，以便一次寻找多个值。

    import scala.util.matching.Regex

    val keyValPattern: Regex = &quot;([0-9a-zA-Z-#() ]+): ([0-9a-zA-Z-#() ]+)&quot;.r

    val input: String =

      &quot;&quot;&quot;background-color: #A03300;

        |background-image: url(img/header100.png);

        |background-position: top center;

        |background-repeat: repeat-x;

        |background-size: 2160px 108px;

        |margin: 0;

        |height: 108px;

        |width: 100%;&quot;&quot;&quot;.stripMargin

    for (patternMatch &lt;- keyValPattern.findAllMatchIn(input))

      println(s&quot;key: $&#123;patternMatch.group(1)&#125; value: $&#123;patternMatch.group(2)&#125;&quot;)

  此例中我们从字符串中解析出多组键值对。每一个匹配值都包含一组子匹配值。结果如下：

    key: background-color value: #A03300

    key: background-image value: url(img

    key: background-position value: top center

    key: background-repeat value: repeat-x

    key: background-size value: 2160px 108px

    key: margin value: 0

    key: height value: 108px

    key: width value: 100
</code></pre>
<h2 id="13-提取器对象"><a href="#13-提取器对象" class="headerlink" title="13.提取器对象"></a>13.提取器对象</h2><pre><code>提取器对象是一个包含有 unapply 方法的单例对象。apply 方法就像一个构造器，接受参数然后创建一个实例对象，反之 unapply 方法接受一个实例对象然后返回最初创建它所用的参数。提取器常用在模式匹配和偏函数中。

    import scala.util.Random

    object CustomerID &#123;

      def apply(name: String) = s&quot;$name--$&#123;Random.nextLong&#125;&quot;

      def unapply(customerID: String): Option[String] = &#123;

        val stringArray: Array[String] = customerID.split(&quot;--&quot;)

        if (stringArray.tail.nonEmpty) Some(stringArray.head) else None

      &#125;

    &#125;

    val customer1ID = CustomerID(&quot;Sukyoung&quot;)  // Sukyoung--23098234908

    customer1ID match &#123;

      case CustomerID(name) =&gt; println(name)  // prints Sukyoung

      case _ =&gt; println(&quot;Could not extract a CustomerID&quot;)

    &#125;

这里 apply 方法用 name 创建一个 CustomerID 字符串。而 unapply 方法正好相反，它返回 name 。当我们调用 CustomerID(&quot;Sukyoung&quot;) ，其实是调用了 CustomerID.apply(&quot;Sukyoung&quot;) 的简化语法。当我们调用 case CustomerID(name) =&gt; println(name)，就是在调用提取器方法。

因为变量定义可以使用模式引入变量，提取器可以用来初始化这个变量，使用 unapply 方法来生成值。

    val customer2ID = CustomerID(&quot;Nico&quot;)

    val CustomerID(name) = customer2ID

    println(name)  // prints Nico

上面的代码等价于 val name = CustomerID.unapply(customer2ID).get。

    val CustomerID(name2) = &quot;--asdfasdfasdf&quot;

如果没有匹配的值，会抛出 scala.MatchError：

    val CustomerID(name3) = &quot;-asdfasdfasdf&quot;

unapply 方法的返回值应当符合下面的某一条：

    如果只是用来判断真假，可以返回一个 Boolean 类型的值。例如 case even()。

    如果只是用来提取单个 T 类型的值，可以返回 Option[T]。

    如果你想要提取多个值，类型分别为 T1,...,Tn，可以把它们放在一个可选的元组中 Option[(T1,...,Tn)]。

有时，要提取的值的数量不是固定的，因此我们想根据输入来返回随机数量的值。这种情况下，你可以用 unapplySeq 方法来定义提取器，此方法返回 Option[Seq[T]]。常见的例子有，用 case List(x, y, z) =&gt; 来解构一个列表 List，以及用一个正则表达式 Regex 来分解一个字符串 String，例如 case r(name, remainingFields @ _*) =&gt;。
</code></pre>
<h2 id="14-FOR-表达式"><a href="#14-FOR-表达式" class="headerlink" title="14.FOR 表达式"></a>14.FOR 表达式</h2><pre><code>Scala 提供一个轻量级的标记方式用来表示 序列推导。推导使用形式为 for (enumerators) yield e 的 for 表达式，此处 enumerators 指一组以分号分隔的枚举器。一个 enumerator 要么是一个产生新变量的生成器，要么是一个过滤器。for 表达式在枚举器产生的每一次绑定中都会计算 e 值，并在循环结束后返回这些值组成的序列。

看下例：

    case class User(name: String, age: Int)

    val userBase = List(User(&quot;Travis&quot;, 28),

      User(&quot;Kelly&quot;, 33),

      User(&quot;Jennifer&quot;, 44),

      User(&quot;Dennis&quot;, 23))

    val twentySomethings = for (user &lt;- userBase if (user.age &gt;=20 &amp;&amp; user.age &lt; 30))

      yield user.name  // i.e. add this to a list

    twentySomethings.foreach(name =&gt; println(name))  // prints Travis Dennis

这里 for 循环后面使用的 yield 语句实际上会创建一个 List。因为当我们说 yield user.name 的时候，它实际上是一个 List[String]。 user &lt;- userBase 是生成器，if (user.age &gt;=20 &amp;&amp; user.age &lt; 30) 是过滤器用来过滤掉那些年龄不是20多岁的人。

下面这个例子复杂一些，使用了两个生成器。它计算了 0 到 n-1 的所有两两求和为 v 的数字的组合：

    def foo(n: Int, v: Int) =

       for (i &lt;- 0 until n;

            j &lt;- i until n if i + j == v)

       yield (i, j)

    foo(10, 10) foreach &#123;

      case (i, j) =&gt;

        println(s&quot;($i, $j) &quot;)  // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5)

    &#125;

这里 n == 10 和 v == 10。在第一次迭代时，i == 0 并且 j == 0 所以 i + j != v 因此没有返回值被生成。在 i 的值递增到 1 之前，j 的值又递增了 9 次。如果没有 if 语句过滤，上面的例子只会打印出如下的结果：

    (0, 0) (0, 1) (0, 2) (0, 3) (0, 4) (0, 5) (0, 6) (0, 7) (0, 8) (0, 9) (1, 1) ...

注意 for 表达式并不局限于使用列表。任何数据类型只要支持 withFilter，map，和 flatMap 操作（不同数据类型可能支持不同的操作）都可以用来做序列推导。

你可以在使用 for 表达式时省略 yield 语句。此时会返回 Unit。当你想要执行一些副作用的时候这很有用。下面的例子输出和上面相同的结果，但是没有使用 yield：

    def foo(n: Int, v: Int) =

       for (i &lt;- 0 until n;

            j &lt;- i until n if i + j == v)

       println(s&quot;($i, $j)&quot;)

    foo(10, 10)
</code></pre>
<h2 id="15-泛型类"><a href="#15-泛型类" class="headerlink" title="15.泛型类"></a>15.泛型类</h2><pre><code>泛型类指可以接受类型参数的类。泛型类在集合类中被广泛使用。
</code></pre>
<h3 id="1-定义一个泛型类"><a href="#1-定义一个泛型类" class="headerlink" title="1.定义一个泛型类"></a>1.定义一个泛型类</h3><pre><code>    泛型类使用方括号 [] 来接受类型参数。一个惯例是使用字母 A 作为参数标识符，当然你可以使用任何参数名称。

        class Stack[A] &#123;

          private var elements: List[A] = Nil

          def push(x: A) &#123; elements = x :: elements &#125;

          def peek: A = elements.head

          def pop(): A = &#123;

            val currentTop = peek

            elements = elements.tail

            currentTop

          &#125;

        &#125;

    上面的 Stack 类的实现中接受类型参数 A。 这表示其内部的列表，var elements: List[A] = Nil，只能够存储类型 A 的元素。方法 def push 只接受类型 A 的实例对象作为参数(注意：elements = x :: elements 将 elements 放到了一个将元素 x 添加到 elements 的头部而生成的新列表中)。
</code></pre>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><pre><code>    要使用一个泛型类，将一个具体类型放到方括号中来代替 A。

        val stack = new Stack[Int]

        stack.push(1)

        stack.push(2)

        println(stack.pop)  // prints 2

        println(stack.pop)  // prints 1

    实例对象 stack 只能接受整型值。然而，如果类型参数有子类型，子类型可以被传入：

        class Fruit

        class Apple extends Fruit

        class Banana extends Fruit

        val stack = new Stack[Fruit]

        val apple = new Apple

        val banana = new Banana

        stack.push(apple)

        stack.push(banana)

    类 Apple 和类 Banana 都继承自类 Fruit，所以我们可以把实例对象 apple 和 banana 压入栈 Fruit 中。

    注意：泛型类型的子类型是*不可传导*的。这表示如果我们有一个字母类型的栈 Stack[Char]，那它不能被用作一个整型的栈 Stack[Int]。否则就是不安全的，因为它将使我们能够在字母型的栈中插入真正的整型值。结论就是，只有当类型 B = A 时， Stack[A] 是 Stack[B] 的子类型才成立。因为此处可能会有很大的限制，Scala 提供了一种 类型参数注释机制 用以控制泛型类型的子类型的行为。
</code></pre>
<h2 id="16-型变"><a href="#16-型变" class="headerlink" title="16.型变"></a>16.型变</h2><pre><code>型变是复杂类型的子类型关系与其组件类型的子类型关系的相关性。 Scala支持 泛型类 的类型参数的型变注释，允许它们是协变的，逆变的，或在没有使用注释的情况下是不变的。 在类型系统中使用型变允许我们在复杂类型之间建立直观的连接，而缺乏型变则会限制类抽象的重用性。

    class Foo[+A] // A covariant class

    class Bar[-A] // A contravariant class

    class Baz[A]  // An invariant class
</code></pre>
<h3 id="1-协变"><a href="#1-协变" class="headerlink" title="1.协变"></a>1.协变</h3><pre><code>    使用注释 +A，可以使一个泛型类的类型参数 A 成为协变。 对于某些类 class List[+A]，使 A 成为协变意味着对于两种类型 A 和 B，如果 A 是 B 的子类型，那么 List[A] 就是 List[B] 的子类型。 这允许我们使用泛型来创建非常有用和直观的子类型关系。

    考虑以下简单的类结构：

        abstract class Animal &#123;

          def name: String

        &#125;

        case class Cat(name: String) extends Animal

        case class Dog(name: String) extends Animal

    类型 Cat 和 Dog 都是 Animal 的子类型。 Scala 标准库有一个通用的不可变的类 sealed abstract class List[+A]，其中类型参数 A 是协变的。 这意味着 List[Cat] 是 List[Animal]，List[Dog] 也是 List[Animal]。 直观地说，猫的列表和狗的列表都是动物的列表是合理的，你应该能够用它们中的任何一个替换 List[Animal]。

    在下例中，方法 printAnimalNames 将接受动物列表作为参数，并且逐行打印出它们的名称。 如果 List[A] 不是协变的，最后两个方法调用将不能编译，这将严重限制 printAnimalNames 方法的适用性。

        object CovarianceTest extends App &#123;

          def printAnimalNames(animals: List[Animal]): Unit = &#123;

            animals.foreach &#123; animal =&gt;

              println(animal.name)

            &#125;

          &#125;

          val cats: List[Cat] = List(Cat(&quot;Whiskers&quot;), Cat(&quot;Tom&quot;))

          val dogs: List[Dog] = List(Dog(&quot;Fido&quot;), Dog(&quot;Rex&quot;))

          printAnimalNames(cats)

          // Whiskers

          // Tom

          printAnimalNames(dogs)

          // Fido

          // Rex

        &#125;
</code></pre>
<h3 id="2-逆变"><a href="#2-逆变" class="headerlink" title="2.逆变"></a>2.逆变</h3><pre><code>    通过使用注释 -A，可以使一个泛型类的类型参数 A 成为逆变。 与协变类似，这会在类及其类型参数之间创建一个子类型关系，但其作用与协变完全相反。 也就是说，对于某个类 class Writer[-A] ，使 A 逆变意味着对于两种类型 A 和 B，如果 A 是 B 的子类型，那么 Writer[B] 是 Writer[A] 的子类型。

    考虑在下例中使用上面定义的类 Cat，Dog 和 Animal ：

        abstract class Printer[-A] &#123;

          def print(value: A): Unit

        &#125;

        这里 Printer[A] 是一个简单的类，用来打印出某种类型的 A。 让我们定义一些特定的子类：

        class AnimalPrinter extends Printer[Animal] &#123;

          def print(animal: Animal): Unit =

            println(&quot;The animal&#39;s name is: &quot; + animal.name)

        &#125;

        class CatPrinter extends Printer[Cat] &#123;

          def print(cat: Cat): Unit =

            println(&quot;The cat&#39;s name is: &quot; + cat.name)

        &#125;

    如果 Printer[Cat] 知道如何在控制台打印出任意 Cat，并且 Printer[Animal] 知道如何在控制台打印出任意 Animal，那么 Printer[Animal] 也应该知道如何打印出 Cat 就是合理的。 反向关系不适用，因为 Printer[Cat] 并不知道如何在控制台打印出任意 Animal。 因此，如果我们愿意，我们应该能够用 Printer[Animal] 替换 Printer[Cat]，而使 Printer[A] 逆变允许我们做到这一点。

        object ContravarianceTest extends App &#123;

          val myCat: Cat = Cat(&quot;Boots&quot;)

          def printMyCat(printer: Printer[Cat]): Unit = &#123;

            printer.print(myCat)

          &#125;

          val catPrinter: Printer[Cat] = new CatPrinter

          val animalPrinter: Printer[Animal] = new AnimalPrinter

          printMyCat(catPrinter)

          printMyCat(animalPrinter)

        &#125;

    这个程序的输出如下：

        The cat&#39;s name is: Boots

        The animal&#39;s name is: Boots
</code></pre>
<h3 id="3-不变"><a href="#3-不变" class="headerlink" title="3.不变"></a>3.不变</h3><pre><code>    默认情况下，Scala中的泛型类是不变的。 这意味着它们既不是协变的也不是逆变的。 在下例中，类 Container 是不变的。 Container[Cat] 不是 Container[Animal]，反之亦然。

        class Container[A](value: A) &#123;

          private var _value: A = value

          def getValue: A = _value

          def setValue(value: A): Unit = &#123;

            _value = value

          &#125;

        &#125;

    可能看起来一个 Container[Cat] 自然也应该是一个 Container[Animal]，但允许一个可变的泛型类成为协变并不安全。 在这个例子中，Container 是不变的非常重要。 假设 Container 实际上是协变的，下面的情况可能会发生：

        val catContainer: Container[Cat] = new Container(Cat(&quot;Felix&quot;))

        val animalContainer: Container[Animal] = catContainer

        animalContainer.setValue(Dog(&quot;Spot&quot;))

        val cat: Cat = catContainer.getValue // 糟糕，我们最终会将一只狗作为值分配给一只猫

    幸运的是，编译器在此之前就会阻止我们。
</code></pre>
<h3 id="4-其他例子"><a href="#4-其他例子" class="headerlink" title="4.其他例子"></a>4.其他例子</h3><pre><code>    另一个可以帮助理解型变的例子是 Scala 标准库中的 trait Function1[-T, +R]。 Function1 表示具有一个参数的函数，其中第一个类型参数 T 表示参数类型，第二个类型参数 R 表示返回类型。 Function1 在其参数类型上是逆变的，并且在其返回类型上是协变的。 对于这个例子，我们将使用文字符号 A =&gt; B 来表示 Function1[A, B]。

    假设前面使用过的类似 Cat，Dog，Animal 的继承关系，加上以下内容：

        abstract class SmallAnimal extends Animal

        case class Mouse(name: String) extends SmallAnimal

    假设我们正在处理接受动物类型的函数，并返回他们的食物类型。 如果我们想要一个 Cat =&gt; SmallAnimal（因为猫吃小动物），但是给它一个 Animal =&gt; Mouse，我们的程序仍然可以工作。 直观地看，一个 Animal =&gt; Mouse 的函数仍然会接受一个 Cat 作为参数，因为 Cat 即是一个 Animal，并且这个函数返回一个 Mouse，也是一个 SmallAnimal。 既然我们可以安全地，隐式地用前者代替后者，我们可以说 Animal =&gt; Mouse 是 Cat =&gt; SmallAnimal 的子类型。
</code></pre>
<h3 id="5-与其他语言的比较"><a href="#5-与其他语言的比较" class="headerlink" title="5.与其他语言的比较"></a>5.与其他语言的比较</h3><pre><code>    某些与 Scala 类似的语言以不同的方式支持型变。 例如，Scala 中的型变注释与 C# 中的非常相似，在定义类抽象时添加型变注释（声明点型变）。 但是在Java中，当类抽象被使用时（使用点型变），才会给出型变注释。
</code></pre>
<h2 id="17-类型上界"><a href="#17-类型上界" class="headerlink" title="17.类型上界"></a>17.类型上界</h2><pre><code>在Scala中，类型参数和抽象类型都可以有一个类型边界约束。这种类型边界在限制类型变量实际取值的同时还能展露类型成员的更多信息。比如像T &lt;: A这样声明的类型上界表示类型变量T应该是类型A的子类。下面的例子展示了类PetContainer的一个类型参数的类型上界。

    abstract class Animal &#123;

     def name: String

    &#125;

    abstract class Pet extends Animal &#123;&#125;

    class Cat extends Pet &#123;

      override def name: String = &quot;Cat&quot;

    &#125;

    class Dog extends Pet &#123;

      override def name: String = &quot;Dog&quot;

    &#125;

    class Lion extends Animal &#123;

      override def name: String = &quot;Lion&quot;

    &#125;

    class PetContainer[P &lt;: Pet](p: P) &#123;

      def pet: P = p

    &#125;

    val dogContainer = new PetContainer[Dog](new Dog)

    val catContainer = new PetContainer[Cat](new Cat)

    // this would not compile

    val lionContainer = new PetContainer[Lion](new Lion)

类PetContainer接受一个必须是Pet子类的类型参数P。因为Dog和Cat都是Pet的子类，所以可以构造PetContainer[Dog]和PetContainer[Cat]。但在尝试构造PetContainer[Lion]的时候会得到下面的错误信息：

    type arguments [Lion] do not conform to class PetContainer&#39;s type parameter bounds [P &lt;: Pet]

这是因为Lion并不是Pet的子类。
</code></pre>
<h2 id="18-类型下界"><a href="#18-类型下界" class="headerlink" title="18.类型下界"></a>18.类型下界</h2><pre><code>类型上界 将类型限制为另一种类型的子类型，而 类型下界 将类型声明为另一种类型的超类型。 术语 B &gt;: A 表示类型参数 B 或抽象类型 B 是类型 A 的超类型。 在大多数情况下，A 将是类的类型参数，而 B 将是方法的类型参数。

下面看一个适合用类型下界的例子：

    trait Node[+B] &#123;

      def prepend(elem: B): Node[B]

    &#125;

    case class ListNode[+B](h: B, t: Node[B]) extends Node[B] &#123;

      def prepend(elem: B): ListNode[B] = ListNode(elem, this)

      def head: B = h

      def tail: Node[B] = t

    &#125;

    case class Nil[+B]() extends Node[B] &#123;

      def prepend(elem: B): ListNode[B] = ListNode(elem, this)

    &#125;

该程序实现了一个单链表。 Nil 表示空元素（即空列表）。 class ListNode 是一个节点，它包含一个类型为 B (head) 的元素和一个对列表其余部分的引用 (tail)。 class Node 及其子类型是协变的，因为我们定义了 +B。

但是，这个程序 不能 编译，因为方法 prepend 中的参数 elem 是协变的 B 类型。 这会出错，因为函数的参数类型是逆变的，而返回类型是协变的。

要解决这个问题，我们需要将方法 prepend 的参数 elem 的型变翻转。 我们通过引入一个新的类型参数 U 来实现这一点，该参数具有 B 作为类型下界。

    trait Node[+B] &#123;

      def prepend[U &gt;: B](elem: U): Node[U]

    &#125;

    case class ListNode[+B](h: B, t: Node[B]) extends Node[B] &#123;

      def prepend[U &gt;: B](elem: U): ListNode[U] = ListNode(elem, this)

      def head: B = h

      def tail: Node[B] = t

    &#125;

    case class Nil[+B]() extends Node[B] &#123;

      def prepend[U &gt;: B](elem: U): ListNode[U] = ListNode(elem, this)

    &#125;

现在我们像下面这么做：

    trait Bird

    case class AfricanSwallow() extends Bird

    case class EuropeanSwallow() extends Bird

    val africanSwallowList= ListNode[AfricanSwallow](AfricanSwallow(), Nil())

    val birdList: Node[Bird] = africanSwallowList

    birdList.prepend(new EuropeanSwallow)

可以为 Node[Bird] 赋值 africanSwallowList，然后再加入一个 EuropeanSwallow。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jackzhangqing.github.io/2023/09/02/32%E4%B8%AA%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qzhang">
      <meta itemprop="description" content="痛点才是奋斗点~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qzhang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/02/32%E4%B8%AA%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">32个经典算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-02 15:49:41 / 修改时间：16:07:40" itemprop="dateCreated datePublished" datetime="2023-09-02T15:49:41+08:00">2023-09-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E4%B8%9A%E7%95%8C/" itemprop="url" rel="index"><span itemprop="name">工业界</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E4%B8%9A%E7%95%8C/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>406</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">1、A 搜索算法</span><br><span class="line"></span><br><span class="line">2、集束搜索</span><br><span class="line"></span><br><span class="line">3、二分查找</span><br><span class="line"></span><br><span class="line">4、分支界定算法</span><br><span class="line"></span><br><span class="line">5、Buchberger算法</span><br><span class="line"></span><br><span class="line">6、数据压缩</span><br><span class="line"></span><br><span class="line">7、密钥交换算法</span><br><span class="line"></span><br><span class="line">8、Dijkstra算法</span><br><span class="line"></span><br><span class="line">9、离散微分算法</span><br><span class="line"></span><br><span class="line">10、动态规划算法</span><br><span class="line"></span><br><span class="line">11、欧几里得算法</span><br><span class="line"></span><br><span class="line">12、期望-最大算法</span><br><span class="line"></span><br><span class="line">13、快速傅里叶变换</span><br><span class="line"></span><br><span class="line">14、梯度下降</span><br><span class="line"></span><br><span class="line">15、哈希算法</span><br><span class="line"></span><br><span class="line">16、堆排序</span><br><span class="line"></span><br><span class="line">17、牛顿法</span><br><span class="line"></span><br><span class="line">18、LLL算法</span><br><span class="line"></span><br><span class="line">19、合并排序 </span><br><span class="line"></span><br><span class="line">20、两次筛选</span><br><span class="line"></span><br><span class="line">21、RANSAC</span><br><span class="line"></span><br><span class="line">22、Karatsuba乘法</span><br><span class="line"></span><br><span class="line">23、最大流量算法</span><br><span class="line"></span><br><span class="line">24、learning学习算法</span><br><span class="line"></span><br><span class="line">25、RSA </span><br><span class="line"></span><br><span class="line">26、Strassen算法</span><br><span class="line"></span><br><span class="line">27、单纯型算法</span><br><span class="line"></span><br><span class="line">28、奇异值分解</span><br><span class="line"></span><br><span class="line">29、求解线性方程组</span><br><span class="line"></span><br><span class="line">30、合并查找算法</span><br><span class="line"></span><br><span class="line">31、维特比算法</span><br><span class="line"></span><br><span class="line">32、Strukturtensor算法</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jackzhangqing.github.io/2023/09/02/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qzhang">
      <meta itemprop="description" content="痛点才是奋斗点~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qzhang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/02/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/" class="post-title-link" itemprop="url">冒泡排序算法思想</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-02 14:48:13 / 修改时间：16:10:32" itemprop="dateCreated datePublished" datetime="2023-09-02T14:48:13+08:00">2023-09-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E4%B8%9A%E7%95%8C/" itemprop="url" rel="index"><span itemprop="name">工业界</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E4%B8%9A%E7%95%8C/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>冒泡排序算法是把较小的元素往前调或者把较大的元素往后调。这种方法主要是通过对相邻两个元素进行大小的比较，根据比较结果和算法规则对该二元素的位置进行交换，这样逐个依次进行比较和交换，就能达到排序目的。冒泡排序的基本思想是，首先将第1个和第2个记录的关键字比较大小，如果是逆序的，就将这两个记录进行交换，再对第2个和第3个记录的关键字进行比较，依次类推，重复进行上述计算，直至完成第(n一1)个和第n个记录的关键字之间的比较，此后，再按照上述过程进行第2次、第3次排序，直至整个序列有序为止。排序过程中要特别注意的是，当相邻两个元素大小一致时，这一步操作就不需要交换位置，因此也说明冒泡排序是一种严格的稳定排序算法，它不改变序列中相同元素之间的相对位置关系。 </p>
<h2 id="冒泡排序的三种写法"><a href="#冒泡排序的三种写法" class="headerlink" title="冒泡排序的三种写法"></a>冒泡排序的三种写法</h2><p>双层循环进行比较，外层循环控制比较趟数，内层循环控制比较交换次数，每趟结束后最大值都在末尾。<br>改进的思路是减少外层循环次数和内层循环的次数。推荐使用改版二，它2个次数都能修改。</p>
<h3 id="1）我最开始是这样写冒泡排序的，效率十分低"><a href="#1）我最开始是这样写冒泡排序的，效率十分低" class="headerlink" title="1）我最开始是这样写冒泡排序的，效率十分低"></a>1）我最开始是这样写冒泡排序的，效率十分低</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/* 缺点是某趟已经有序时，后面的次数还是会继续，外层循环次数总是max，内层循环次数还是 max - i */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">#define N 9</span><br><span class="line">#define MAXSIZE 10000  /* 用于要排序数组个数最大值，可根据需要修改 */</span><br><span class="line"> </span><br><span class="line">typedef struct &#123;</span><br><span class="line">	int r[MAXSIZE+1];	/* 用于存储要排序数组，r[0]用作哨兵或临时变量 */</span><br><span class="line">	int length;			/* 用于记录顺序表的长度 */</span><br><span class="line">&#125; SqList;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void swap(SqList *L, int i, int j);</span><br><span class="line">void BubbleSort0(SqList *L);</span><br><span class="line">void print(SqList L);</span><br><span class="line">int main(void) &#123;</span><br><span class="line">	int i;</span><br><span class="line">	int d[N]= &#123;50,10,90,30,70,40,80,60,20&#125;;</span><br><span class="line">	SqList list;</span><br><span class="line"> </span><br><span class="line">	for(i=0; i&lt;N; i++)</span><br><span class="line">		list.r[i+1]=d[i];</span><br><span class="line">	list.length=N;</span><br><span class="line">	printf(&quot;排序前:\n&quot;);</span><br><span class="line">	print(list);</span><br><span class="line"> </span><br><span class="line">	printf(&quot;冒泡排序后:\n&quot;);</span><br><span class="line">	BubbleSort0(&amp;list);</span><br><span class="line">	print(list);</span><br><span class="line"> </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void swap(SqList *L, int i, int j) &#123;</span><br><span class="line">	int temp = L-&gt;r[i];</span><br><span class="line">	L-&gt;r[i] = L-&gt;r[j];</span><br><span class="line">	L-&gt;r[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void print(SqList L) &#123;</span><br><span class="line">	int i;</span><br><span class="line">	for(i=1; i&lt;L.length; i++)</span><br><span class="line">		printf(&quot;%d,&quot;,L.r[i]);</span><br><span class="line">	printf(&quot;%d&quot;,L.r[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 对顺序表L作交换排序（冒泡排序初级版） */</span><br><span class="line">void BubbleSort0(SqList *L) &#123;</span><br><span class="line">	int i, j;</span><br><span class="line">	for(i = 1; i &lt; L-&gt;length; i++) &#123;</span><br><span class="line">		for(j = i + 1; j &lt;= L-&gt;length; j++) &#123;</span><br><span class="line">			if(L-&gt;r[i] &gt; L-&gt;r[j]) &#123;</span><br><span class="line">				swap(L, i, j);/* 交换L-&gt;r[i]与L-&gt;r[j]的值 */</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2）改进1：记录交换位置，可以省略下趟不必要的比较（如果后面几个元素已经是有序的，第二趟就直接不用比较这几个元素。"><a href="#2）改进1：记录交换位置，可以省略下趟不必要的比较（如果后面几个元素已经是有序的，第二趟就直接不用比较这几个元素。" class="headerlink" title="2）改进1：记录交换位置，可以省略下趟不必要的比较（如果后面几个元素已经是有序的，第二趟就直接不用比较这几个元素。"></a>2）改进1：记录交换位置，可以省略下趟不必要的比较（如果后面几个元素已经是有序的，第二趟就直接不用比较这几个元素。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">#define N 9</span><br><span class="line">#define MAXSIZE 10000  /* 用于要排序数组个数最大值，可根据需要修改 */</span><br><span class="line"> </span><br><span class="line">typedef struct &#123;</span><br><span class="line">	int r[MAXSIZE+1];	/* 用于存储要排序数组，r[0]用作哨兵或临时变量 */</span><br><span class="line">	int length;			/* 用于记录顺序表的长度 */</span><br><span class="line">&#125; SqList;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void swap(SqList *L, int i, int j);</span><br><span class="line">void BubbleSort0(SqList *L);</span><br><span class="line">void print(SqList L);</span><br><span class="line">int main(void) &#123;</span><br><span class="line">	int i;</span><br><span class="line">	int d[N]= &#123;50,10,90,30,70,40,80,60,20&#125;;</span><br><span class="line">	SqList list;</span><br><span class="line"> </span><br><span class="line">	for(i=0; i&lt;N; i++)</span><br><span class="line">		list.r[i+1]=d[i];</span><br><span class="line">	list.length=N;</span><br><span class="line">	printf(&quot;排序前:\n&quot;);</span><br><span class="line">	print(list);</span><br><span class="line"> </span><br><span class="line">	printf(&quot;冒泡排序后:\n&quot;);</span><br><span class="line">	BubbleSort0(&amp;list);</span><br><span class="line">	print(list);</span><br><span class="line"> </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void swap(SqList *L, int i, int j) &#123;</span><br><span class="line">	int temp = L-&gt;r[i];</span><br><span class="line">	L-&gt;r[i] = L-&gt;r[j];</span><br><span class="line">	L-&gt;r[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void print(SqList L) &#123;</span><br><span class="line">	int i;</span><br><span class="line">	for(i=1; i&lt;L.length; i++)</span><br><span class="line">		printf(&quot;%d,&quot;,L.r[i]);</span><br><span class="line">	printf(&quot;%d&quot;,L.r[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 对顺序表L作交换排序（冒泡排序初级版） */</span><br><span class="line">void BubbleSort0(SqList *L) &#123;</span><br><span class="line">	int i, j;</span><br><span class="line">	for(i = 1; i &lt; L-&gt;length; i++) &#123;</span><br><span class="line">		for(j = L-&gt;length - 1; j &gt;= i; j--) &#123; /* 注意j是从后往前循环 */</span><br><span class="line">			if(L-&gt;r[j] &gt; L-&gt;r[j+1]) &#123; /* 若前者大于后者（注意这里与上一算法的差异）*/</span><br><span class="line">				swap(L, j, j+1);/* 交换L-&gt;r[j]与L-&gt;r[j+1]的值 */</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="改进2：双向冒泡，正向找最大-从最小元素交换位置处开始比较，找到最大元素并记录交换位置-，反向找最小-从最大元素交换位置处开始比较，找到最小元素并记录交换位置"><a href="#改进2：双向冒泡，正向找最大-从最小元素交换位置处开始比较，找到最大元素并记录交换位置-，反向找最小-从最大元素交换位置处开始比较，找到最小元素并记录交换位置" class="headerlink" title="改进2：双向冒泡，正向找最大(从最小元素交换位置处开始比较，找到最大元素并记录交换位置)，反向找最小(从最大元素交换位置处开始比较，找到最小元素并记录交换位置)."></a>改进2：双向冒泡，正向找最大(从最小元素交换位置处开始比较，找到最大元素并记录交换位置)，反向找最小(从最大元素交换位置处开始比较，找到最小元素并记录交换位置).</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">#define N 9</span><br><span class="line">#define MAXSIZE 10000  /* 用于要排序数组个数最大值，可根据需要修改 */</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">typedef struct &#123;</span><br><span class="line">	int r[MAXSIZE+1];	/* 用于存储要排序数组，r[0]用作哨兵或临时变量 */</span><br><span class="line">	int length;			/* 用于记录顺序表的长度 */</span><br><span class="line">&#125; SqList;</span><br><span class="line"> </span><br><span class="line">typedef int Status;</span><br><span class="line">void swap(SqList *L, int i, int j);</span><br><span class="line">void BubbleSort0(SqList *L);</span><br><span class="line">void print(SqList L);</span><br><span class="line">int main(void) &#123;</span><br><span class="line">	int i;</span><br><span class="line">	int d[N]= &#123;50,10,90,30,70,40,80,60,20&#125;;</span><br><span class="line">	SqList list;</span><br><span class="line"> </span><br><span class="line">	for(i=0; i&lt;N; i++)</span><br><span class="line">		list.r[i+1]=d[i];</span><br><span class="line">	list.length=N;</span><br><span class="line">	printf(&quot;排序前:\n&quot;);</span><br><span class="line">	print(list);</span><br><span class="line"> </span><br><span class="line">	printf(&quot;冒泡排序后:\n&quot;);</span><br><span class="line">	BubbleSort0(&amp;list);</span><br><span class="line">	print(list);</span><br><span class="line"> </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void swap(SqList *L, int i, int j) &#123;</span><br><span class="line">	int temp = L-&gt;r[i];</span><br><span class="line">	L-&gt;r[i] = L-&gt;r[j];</span><br><span class="line">	L-&gt;r[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void print(SqList L) &#123;</span><br><span class="line">	int i;</span><br><span class="line">	for(i=1; i&lt;L.length; i++)</span><br><span class="line">		printf(&quot;%d,&quot;,L.r[i]);</span><br><span class="line">	printf(&quot;%d&quot;,L.r[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* 对顺序表L作交换排序（冒泡排序初级版） */</span><br><span class="line">void BubbleSort0(SqList *L) &#123;</span><br><span class="line">	int i, j;</span><br><span class="line">	Status flag = TRUE;			/* flag用来作为标记 */</span><br><span class="line">	for(i = 1; i &lt; L-&gt;length &amp;&amp; flag; i++) &#123; /* 若flag为true说明有过数据交换，否则停止循环 */</span><br><span class="line">		flag = FALSE;				/* 初始为False */</span><br><span class="line">		for(j = L-&gt;length - 1; j &gt;= i; j--) &#123;</span><br><span class="line">			if(L-&gt;r[j] &gt; L-&gt;r[j+1]) &#123;</span><br><span class="line">				swap(L, j, j+1);	/* 交换L-&gt;r[j]与L-&gt;r[j+1]的值 */</span><br><span class="line">				flag = TRUE;		/* 如果有数据交换，则flag为true */</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jackzhangqing.github.io/2023/09/02/LeteCode-Solution-Overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qzhang">
      <meta itemprop="description" content="痛点才是奋斗点~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qzhang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/02/LeteCode-Solution-Overview/" class="post-title-link" itemprop="url">LeteCode Solution Overview</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-02 13:20:49 / 修改时间：16:10:30" itemprop="dateCreated datePublished" datetime="2023-09-02T13:20:49+08:00">2023-09-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">找工作</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44232942/article/details/106457056">LeteCode 解题总览</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Qzhang"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Qzhang</p>
  <div class="site-description" itemprop="description">痛点才是奋斗点~</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jackzhangqing" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jackzhangqing" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jackcodingqing@gmail.com" title="E-Mail → mailto:jackcodingqing@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://m.weibo.cn/" title="Weibo → https:&#x2F;&#x2F;m.weibo.cn&#x2F;" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://scholar.google.com/citations?hl=en&view_op=list_works&gmla=AP6z3OaD-tXcIdA7232yuM864uP7HSb4Eljmcn-TQNwtirTGDNWcxqwzx5u9hQ4UtaBmkc6W2WudOn-Zls1TYg&user=aQQy_WAAAAAJ" title="Google → https:&#x2F;&#x2F;scholar.google.com&#x2F;citations?hl&#x3D;en&amp;view_op&#x3D;list_works&amp;gmla&#x3D;AP6z3OaD-tXcIdA7232yuM864uP7HSb4Eljmcn-TQNwtirTGDNWcxqwzx5u9hQ4UtaBmkc6W2WudOn-Zls1TYg&amp;user&#x3D;aQQy_WAAAAAJ" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Google</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.researchgate.net/" title="ResearchGate → https:&#x2F;&#x2F;www.researchgate.net&#x2F;" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>ResearchGate</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.csdn.net/" title="https:&#x2F;&#x2F;www.csdn.net&#x2F;" rel="noopener" target="_blank">CSDN</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    
    <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
    

     <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-08 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qzhang</span>
</div>
  <div class="powered-by">
    <!--由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动 -->
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
});
</script> 

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/01/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
