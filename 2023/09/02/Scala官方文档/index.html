<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jackzhangqing.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1.介绍1.什么是ScalaScala是一门现代的多范式语言，志在以简洁、优雅及类型安全的方式来表达常用的编程模型。它平滑地集成了面向对象和函数式语言的特性。 2.Scala是面向对象编程语言鉴于一切值都是对象，可以说Scala是一门纯面向对象的语言。对象的类型和行为是由类和特质来描述的。类可以由子类化和一种灵活的、基于mixin的组合机制（它可作为多重继承的简单替代方案）来扩展。 3.Scala">
<meta property="og:type" content="article">
<meta property="og:title" content="Scala官方文档">
<meta property="og:url" content="https://jackzhangqing.github.io/2023/09/02/Scala%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/index.html">
<meta property="og:site_name" content="Qzhang">
<meta property="og:description" content="1.介绍1.什么是ScalaScala是一门现代的多范式语言，志在以简洁、优雅及类型安全的方式来表达常用的编程模型。它平滑地集成了面向对象和函数式语言的特性。 2.Scala是面向对象编程语言鉴于一切值都是对象，可以说Scala是一门纯面向对象的语言。对象的类型和行为是由类和特质来描述的。类可以由子类化和一种灵活的、基于mixin的组合机制（它可作为多重继承的简单替代方案）来扩展。 3.Scala">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-09-02T07:59:17.000Z">
<meta property="article:modified_time" content="2023-09-02T08:35:57.754Z">
<meta property="article:author" content="Qzhang">
<meta property="article:tag" content="Scala文档">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jackzhangqing.github.io/2023/09/02/Scala%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Scala官方文档 | Qzhang</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Qzhang" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Qzhang</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">奔赴山海, 保持热爱</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/luumod" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jackzhangqing.github.io/2023/09/02/Scala%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Qzhang">
      <meta itemprop="description" content="痛点才是奋斗点~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qzhang">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Scala官方文档
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-02 15:59:17 / 修改时间：16:35:57" itemprop="dateCreated datePublished" datetime="2023-09-02T15:59:17+08:00">2023-09-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E4%B8%9A%E7%95%8C/" itemprop="url" rel="index"><span itemprop="name">工业界</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E4%B8%9A%E7%95%8C/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91Spark/" itemprop="url" rel="index"><span itemprop="name">大数据高级开发Spark</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>30k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>55 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><h3 id="1-什么是Scala"><a href="#1-什么是Scala" class="headerlink" title="1.什么是Scala"></a>1.什么是Scala</h3><p>Scala是一门现代的多范式语言，志在以简洁、优雅及类型安全的方式来表达常用的编程模型。它平滑地集成了面向对象和函数式语言的特性。</p>
<h3 id="2-Scala是面向对象编程语言"><a href="#2-Scala是面向对象编程语言" class="headerlink" title="2.Scala是面向对象编程语言"></a>2.Scala是面向对象编程语言</h3><p>鉴于一切值都是对象，可以说Scala是一门纯面向对象的语言。对象的类型和行为是由类和特质来描述的。类可以由子类化和一种灵活的、基于mixin的组合机制（它可作为多重继承的简单替代方案）来扩展。</p>
<h3 id="3-Scala是函数式编程语言"><a href="#3-Scala是函数式编程语言" class="headerlink" title="3.Scala是函数式编程语言"></a>3.Scala是函数式编程语言</h3><p>鉴于一切函数都是值，又可以说Scala是一门函数式语言。Scala为定义匿名函数提供了轻量级的语法，支持高阶函数，允许函数嵌套及柯里化。Scala的样例类和内置支持的模式匹配代数模型在许多函数式编程语言中都被使用。对于那些并非类的成员函数，单例对象提供了便捷的方式去组织它们。<br>    此外，通过对提取器的一般扩展，Scala的模式匹配概念使用了right-ignoring序列模式，自然地延伸到XML数据的处理。其中，for表达<br>式对于构建查询很有用。这些特性使得Scala成为开发web服务等程序的理想选择。</p>
<h3 id="4-Scala是静态类型的"><a href="#4-Scala是静态类型的" class="headerlink" title="4.Scala是静态类型的"></a>4.Scala是静态类型的</h3><p>Scala配备了一个拥有强大表达能力的类型系统，它可以静态地强制以安全、一致的方式使用抽象。典型来说，这个类型系统支持：<br>    1）泛型类<br>    2）型变注解<br>    3）上、下 类型边界<br>    4）作为对象成员的内部类和抽象类型<br>    5）复合类型<br>    6）显式类型的自我引用<br>    7）隐式参数和隐式转化<br>    8）多态方法<br>    9）类型推断让用户不需要标明额外的类型信息。这些特性结合起来为安全可重用的编程抽象以及类型安全的扩展提供了强大的基础。</p>
<h3 id="5-Scala是可扩展的"><a href="#5-Scala是可扩展的" class="headerlink" title="5.Scala是可扩展的"></a>5.Scala是可扩展的</h3><p>在实践中，特定领域应用的发展往往需要特定领域的语言扩展。Scala提供了一种语言机制的独特组合方式，使得可以方便地以库的形式添加新的语言结构。<br>    很多场景下，这些扩展可以不通过类似宏（macros）的元编程工具完成。例如：<br>    1）隐式类允许给已有的类型添加扩展方法。<br>    2）字符串插值可以让用户使用自定义的插值器进行扩展。</p>
<h3 id="6-Scala互操作"><a href="#6-Scala互操作" class="headerlink" title="6.Scala互操作"></a>6.Scala互操作</h3><p>Scala设计的目标是与流行的Java运行环境（JRE）进行良好的互操作，特别是与主流的面向对象编程语言——Java的互操作尽可能的平滑。Java的最新特性如函数接口（SAMs）、lambda表达式、注解及泛型类 在Scala中都有类似的实现。<br>    另外有些Java中并没有的特性，如缺省参数值和带名字的参数等，也是尽可能地向Java靠拢。Scala拥有类似Java的编译模型（独立编译、<br>动态类加载），且允许使用已有的成千上万的高质量类库。</p>
<h2 id="2-基础"><a href="#2-基础" class="headerlink" title="2.基础"></a>2.基础</h2><h3 id="2-1表达式-表达式是可计算语句。"><a href="#2-1表达式-表达式是可计算语句。" class="headerlink" title="2.1表达式:表达式是可计算语句。"></a>2.1表达式:表达式是可计算语句。</h3><pre><code>例如：1+1
常量: 
    1.使用val定义
    2.常量（values）不能重新被赋值。
    3.常量（values）的类型可以被推断,也可以显示地声明类型
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val x=1+1  或 val x:Int=1+1</span><br><span class="line">x=3 //编译不通过</span><br></pre></td></tr></table></figure>

变量: 使用var定义
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x=1+1 </span><br><span class="line">x=3</span><br><span class="line">println(x*x)</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="2-2块-组合几个表达式-并且用-包裹的称之为代码块。代码块中最后一个表达式的结果也是整个块的结果。"><a href="#2-2块-组合几个表达式-并且用-包裹的称之为代码块。代码块中最后一个表达式的结果也是整个块的结果。" class="headerlink" title="2.2块: 组合几个表达式,并且用{}包裹的称之为代码块。代码块中最后一个表达式的结果也是整个块的结果。"></a>2.2块: 组合几个表达式,并且用{}包裹的称之为代码块。代码块中最后一个表达式的结果也是整个块的结果。</h3><pre><code>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(&#123;</span><br><span class="line">			val x = 1 + 1</span><br><span class="line">			x + 1</span><br><span class="line">&#125;) // 3</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="2-3函数-函数是带参数的表达式。"><a href="#2-3函数-函数是带参数的表达式。" class="headerlink" title="2.3函数:函数是带参数的表达式。"></a>2.3函数:函数是带参数的表达式。</h3><pre><code>1.可以定义一个匿名函数（即无名称），返回给定的整数加一的结果：
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x:Int)=&gt;x+1</span><br></pre></td></tr></table></figure>
    =&gt;的左边是参数列表，右边是一个包含参数的表达式。
2.带名字的函数:
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val addOne=(x:Int)=&gt;x+1</span><br><span class="line">println(addOne(1))//2</span><br></pre></td></tr></table></figure>
3.多个参数的函数
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val add=(x:Int,y:Int)=&gt;x+y</span><br><span class="line">println(add(1,2))//3</span><br></pre></td></tr></table></figure>
4.无参数的函数
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val getTheAnswer=()=&gt;42</span><br><span class="line">      println(getTheAnswer())//42</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="2-4方法-方法看起来和行为与函数非常相似，但是它们之间有几个关键的区别。"><a href="#2-4方法-方法看起来和行为与函数非常相似，但是它们之间有几个关键的区别。" class="headerlink" title="2.4方法:方法看起来和行为与函数非常相似，但是它们之间有几个关键的区别。"></a>2.4方法:方法看起来和行为与函数非常相似，但是它们之间有几个关键的区别。</h3><pre><code>1.方法是用def关键字定义的。def后面是一个名称、参数列表、返回类型和方法体。
2.格式:
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     [修饰符] def methodName(name1:ArgsType1,name2:ArgsType2)[:retrunType]=&#123;</span><br><span class="line">      	//方法体</span><br><span class="line">   	&#125;</span><br><span class="line"></span><br><span class="line">   	def add(x: Int, y: Int): Int = x + y</span><br><span class="line">println(add(1, 2)) // 3</span><br></pre></td></tr></table></figure>
3.方法可以接受多个参数列表
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">     def addThenMultiply(x: Int, y: Int)(multiplier: Int): Int = (x + y) * multiplier</span><br><span class="line">println(addThenMultiply(1, 2)(3)) // 9</span><br></pre></td></tr></table></figure>
4.方法可以接受没有参数列表
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def name: String = System.getProperty(&quot;user.name&quot;)</span><br><span class="line">	println(&quot;Hello, &quot; + name + &quot;!&quot;)</span><br></pre></td></tr></table></figure>
5.还有其他一些区别，但是现在，可以将它们看作类似于函数的东西。
    方法也可以有多行表达式。
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def getSquareString(input: Double): String = &#123;</span><br><span class="line">			val square = input * input</span><br><span class="line">			square.toString</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    方法体的最后一个表达式就是方法的返回值。（Scala中也有一个return关键字，但是很少使用）
</code></pre>
<h3 id="2-5类-可以用class关键字来定义一个类，后面跟着它的名字和构造器。"><a href="#2-5类-可以用class关键字来定义一个类，后面跟着它的名字和构造器。" class="headerlink" title="2.5类:可以用class关键字来定义一个类，后面跟着它的名字和构造器。"></a>2.5类:可以用class关键字来定义一个类，后面跟着它的名字和构造器。</h3><pre><code>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Greeter(prefix: String, suffix: String) &#123;</span><br><span class="line">  def greet(name: String): Unit =</span><br><span class="line">    println(prefix + name + suffix)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    可以使用new关键字来构建一个类的实例。
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val greeter = new Greeter(&quot;Hello, &quot;, &quot;!&quot;)</span><br><span class="line">greeter.greet(&quot;Scala developer&quot;) // Hello, Scala developer!</span><br></pre></td></tr></table></figure>
    我们以后再深入讨论。
</code></pre>
<h3 id="2-6样例类-Scala有一种特殊的类叫做样例类（case-class）。默认情况下，样例类一般用于不可变对象，并且可作值比较。你可以使用case-class关键字来定义样例类。"><a href="#2-6样例类-Scala有一种特殊的类叫做样例类（case-class）。默认情况下，样例类一般用于不可变对象，并且可作值比较。你可以使用case-class关键字来定义样例类。" class="headerlink" title="2.6样例类:Scala有一种特殊的类叫做样例类（case class）。默认情况下，样例类一般用于不可变对象，并且可作值比较。你可以使用case class关键字来定义样例类。"></a>2.6样例类:Scala有一种特殊的类叫做样例类（case class）。默认情况下，样例类一般用于不可变对象，并且可作值比较。你可以使用case class关键字来定义样例类。</h3><pre><code>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">case class Point(x: Int, y: Int)</span><br><span class="line"></span><br><span class="line">   # 可以不使用new关键字来构建一个类的实例。</span><br><span class="line">val point = Point(1, 2)</span><br><span class="line">val anotherPoint = Point(1, 2)</span><br><span class="line">val yetAnotherPoint = Point(2, 2)</span><br><span class="line"></span><br><span class="line">   # 并且它们的值可以进行比较。</span><br><span class="line">if (point == anotherPoint) &#123;</span><br><span class="line">  println(point + &quot; and &quot; + anotherPoint + &quot; are the same.&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  println(point + &quot; and &quot; + anotherPoint + &quot; are different.&quot;)</span><br><span class="line">&#125; // Point(1,2) and Point(1,2) are the same.</span><br><span class="line">if (point == yetAnotherPoint) &#123;</span><br><span class="line">  println(point + &quot; and &quot; + yetAnotherPoint + &quot; are the same.&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  println(point + &quot; and &quot; + yetAnotherPoint + &quot; are different.&quot;)</span><br><span class="line">&#125; // Point(1,2) and Point(2,2) are different.</span><br></pre></td></tr></table></figure>
    我们以后再深入讨论。
</code></pre>
<h3 id="2-7对象-对象是它们自己定义的单实例，你可以把它看作它自己的类的单例。"><a href="#2-7对象-对象是它们自己定义的单实例，你可以把它看作它自己的类的单例。" class="headerlink" title="2.7对象:对象是它们自己定义的单实例，你可以把它看作它自己的类的单例。"></a>2.7对象:对象是它们自己定义的单实例，你可以把它看作它自己的类的单例。</h3><pre><code>    可以使用object关键字定义对象:
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	object IdFactory &#123;</span><br><span class="line">	  private var counter = 0</span><br><span class="line">	  def create(): Int = &#123;</span><br><span class="line">	    counter += 1</span><br><span class="line">	    counter</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">可以通过引用对象的名称访问对象。</span><br><span class="line">val newId: Int = IdFactory.create()</span><br><span class="line">println(newId) // 1</span><br><span class="line">val newerId: Int = IdFactory.create()</span><br><span class="line">println(newerId) // 2</span><br></pre></td></tr></table></figure>
    我们以后再深入讨论。
</code></pre>
<h3 id="2-8特质-特质是包含某些字段和方法的类型。可以组合多个特质。"><a href="#2-8特质-特质是包含某些字段和方法的类型。可以组合多个特质。" class="headerlink" title="2.8特质:特质是包含某些字段和方法的类型。可以组合多个特质。"></a>2.8特质:特质是包含某些字段和方法的类型。可以组合多个特质。</h3><pre><code>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">可以使用trait关键字定义特质:</span><br><span class="line">	trait Greeter &#123;</span><br><span class="line">	  def greet(name: String): Unit</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">特质可以有默认的实现:</span><br><span class="line">	trait Greeter &#123;</span><br><span class="line">	  def greet(name: String): Unit =</span><br><span class="line">	    println(&quot;Hello, &quot; + name + &quot;!&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">可以使用extends关键字来继承特质，使用override关键字来覆盖默认的实现。</span><br><span class="line">	class DefaultGreeter extends Greeter</span><br><span class="line">	class CustomizableGreeter(prefix: String, postfix: String) extends Greeter &#123;</span><br><span class="line">	  override def greet(name: String): Unit = &#123;</span><br><span class="line">	    println(prefix + name + postfix)</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	val greeter = new DefaultGreeter()</span><br><span class="line">	greeter.greet(&quot;Scala developer&quot;) // Hello, Scala develop</span><br><span class="line">	val customGreeter = new CustomizableGreeter(&quot;How are you, &quot;, &quot;?&quot;)</span><br><span class="line">	customGreeter.greet(&quot;Scala developer&quot;) // How are you, Scala developer?</span><br></pre></td></tr></table></figure>
    在这里，DefaultGreeter只继承了一个特征，但它可以继承多个特征。

    我们以后将深入研究特征。
</code></pre>
<h3 id="2-9主方法-主方法是一个程序的入口点。JVM要求一个名为main的主方法，接受一个字符串数组的参数。"><a href="#2-9主方法-主方法是一个程序的入口点。JVM要求一个名为main的主方法，接受一个字符串数组的参数。" class="headerlink" title="2.9主方法:主方法是一个程序的入口点。JVM要求一个名为main的主方法，接受一个字符串数组的参数。"></a>2.9主方法:主方法是一个程序的入口点。JVM要求一个名为main的主方法，接受一个字符串数组的参数。</h3><pre><code>    使用对象，可以将主方法定义如下：
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object Main &#123;</span><br><span class="line">  def main(args: Array[String]): Unit =</span><br><span class="line">    println(&quot;Hello, Scala developer!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="3-统一类型"><a href="#3-统一类型" class="headerlink" title="3.统一类型"></a>3.统一类型</h2><pre><code>在Scala中，所有的值都有类型，包括数值和函数。下图阐述了类型层次结构的一个子集。
        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Any （顶级类型）</span><br><span class="line">AnyVal 		AnyRef(java.lang.Object)</span><br><span class="line">  ^				List</span><br><span class="line">  |				Option</span><br><span class="line">Double			YourClass</span><br><span class="line">Dloat				^</span><br><span class="line">Long  				|</span><br><span class="line">Int 				|</span><br><span class="line">Short 				|</span><br><span class="line">Byte 				|</span><br><span class="line">Boolean 			|</span><br><span class="line">Char 				Null</span><br><span class="line">Unit				^</span><br><span class="line">  ^              	|</span><br><span class="line">  |					|</span><br><span class="line">Nothing（底部类型）</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="3-1Scala类型层级"><a href="#3-1Scala类型层级" class="headerlink" title="3.1Scala类型层级"></a>3.1Scala类型层级</h3><p>Any是所有类型的超类型，也称为顶级类型。它定义了一些通用的方法如equals、hashCode和toString。Any有两个直接子类：AnyVal和<br>AnyRef。<br>    AnyVal代表值类型。有9个预定义的非空的值类型分别是：Double、Float、Long、Int、Short、Byte、Char、Unit和Boolean。Unit是<br>不带任何意义的值类型，它仅有一个实例可以像这样声明：()。所有的函数必须有返回，所以说有时候Unit也是有用的返回类型。<br>    AnyRef代表引用类型。所有非值类型都被定义为引用类型。在Scala中，每个用户自定义的类型都是AnyRef的子类型。如果Scala被应用在<br>Java的运行环境中，AnyRef相当于java.lang.Object。<br>    值类的空间是平坦的；所有的值类都是scala.AnyVal的子类型，但是它们不是其他类的子类。但是不同的值类类型之间可以隐式地互相转<br>换。例如，需要的时候，类scala.Int的实例可以通过隐式转换放宽到类scala.Long的实例；Int支持min、max、until、to、abs等操作，其实是从类Int隐式转换到scala.runtime.RichInt的。<br>    AnyRef是引用类型。所有非值类型都定义为引用类型.它其实是Java平台上java.lang.Object类的别名。因此Java里写的类和Scala里写<br>的都继承自AnyRef。<br>    Scala类与Java类的不同在于它们还继承自一个名为ScalaObject的特别记号特质。是想要通过ScalaObject包含的Scala编译器定义和实<br>现的方法让Scala程序的执行更高效。</p>
<pre><code>类型转化.
下面是一个示例，说明了字符串、整型、布尔值和函数都是对象，这一点和其他对象一样：
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   val list: List[Any] = List(</span><br><span class="line">	  &quot;a string&quot;,</span><br><span class="line">	  732,  // an integer</span><br><span class="line">	  &#x27;c&#x27;,  // a character</span><br><span class="line">	  true, // a boolean value</span><br><span class="line">	  () =&gt; &quot;an anonymous function returning a string&quot;</span><br><span class="line">	)</span><br><span class="line">list.foreach(element =&gt; println(element))</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="3-2类型转化"><a href="#3-2类型转化" class="headerlink" title="3.2类型转化"></a>3.2类型转化</h3><pre><code>    值类型可以按照下面的方向进行转换： 

    Byte-&gt;Short-&gt;Int-&gt;Long-&gt;Float-&gt;Double

                  ^

                  |

                 Char

    例1:

        val x: Long = 987654321

        val y: Float = x  // 9.8765434E8 (note that some precision is lost in this case)

        val face: Char = &#39;☺&#39;

        val number: Int = face  // 9786

    例2:转换是单向，下面这样写将不会通过编译。

        val x: Long = 987654321

        val y: Float = x  // 9.8765434E8

        val z: Long = y  // Does not conform
</code></pre>
<h3 id="3-3Nothing和Null"><a href="#3-3Nothing和Null" class="headerlink" title="3.3Nothing和Null"></a>3.3Nothing和Null</h3><pre><code>    scala.Null和scala.Nothing是用统一的方式处理Scala面向对象类型系统的某些&quot;边界情况&quot;的特殊类型。

    Nothing是所有类型的子类型，也称为底层类型。没有一个值是Nothing类型的。它的用途之一是给出非正常终止的信号，如抛出异常、程序退出或者一个无限循环（可以理解为它是一个不对值进行定义的表达式的类型，或者是一个不能正常返回的方法）。

    Null是所有引用类型的子类型（即AnyRef的任意子类型）。它有一个单例值由关键字null所定义。Null主要是使得Scala满足和其他JVM语言的互操作性，但是几乎不应该在Scala代码中使用。我们将在后面的章节中介绍null的替代方案。

    例1:

        def error(message: String): Nothing = throw new RuntimeException(message)

    例2:

        def divide(x: Int, y: Int): Int = if(y != 0) x / y else error(&quot;Can&#39;t divide by zero&quot;)
</code></pre>
<h2 id="4-类"><a href="#4-类" class="headerlink" title="4.类"></a>4.类</h2><pre><code>Scala中的类是用于创建对象的蓝图，其中包含了方法、常量、变量、类型、对象、特质、类，这些统称为成员。类型、对象和特质将在后面的文章中介绍。
</code></pre>
<h3 id="4-1定义类"><a href="#4-1定义类" class="headerlink" title="4.1定义类"></a>4.1定义类</h3><h4 id="4-1-1格式：class-类名-private-package-this-主构造器参数列表-extends-类-特质-with-特质1-with-特质2"><a href="#4-1-1格式：class-类名-private-package-this-主构造器参数列表-extends-类-特质-with-特质1-with-特质2" class="headerlink" title="4.1.1格式：class 类名 private[package&#x2F;this] (主构造器参数列表) extends 类&#x2F;特质 with 特质1 with 特质2{}"></a>4.1.1格式：class 类名 private[package&#x2F;this] (主构造器参数列表) extends 类&#x2F;特质 with 特质1 with 特质2{}</h4><pre><code>    eg: class Student(name:String,age:Int) extends Father with T1 with T2&#123;

      //属性

      //方法

      //主构造器中的代码

      println(&quot;.....&quot;)

      def this()=&#123;

        //.......

      &#125;

    &#125;
</code></pre>
<h4 id="4-1-2案例："><a href="#4-1-2案例：" class="headerlink" title="4.1.2案例："></a>4.1.2案例：</h4><pre><code> 	 例1:一个最简的类的定义就是关键字class+标识符，类名必须是大写。

    	class User

        val user1 = new User

      例2:关键字new被用于创建类的实例。User由于没有定义任何构造器，因而只有一个不带任何参数的默认构造器。然而，你通常需要一个构造器和类体。下面是类定义的一个例子：

        class Point(var x: Int, var y: Int) &#123;

          def move(dx: Int, dy: Int): Unit = &#123;

            x = x + dx

            y = y + dy

          &#125;

          override def toString: String =

            s&quot;($x, $y)&quot;

        &#125;

        val point1 = new Point(2, 3)

        point1.x  // 2

        println(point1)  // prints (2, 3)
</code></pre>
<h3 id="4-2构造器"><a href="#4-2构造器" class="headerlink" title="4.2构造器"></a>4.2构造器</h3><h4 id="4-2-1-概念"><a href="#4-2-1-概念" class="headerlink" title="4.2.1:概念:"></a>4.2.1:概念:</h4><pre><code>        主构造器 : 与类的定义交织在一起

          辅助构造器 :  

            1.通过方法名this重载构造器 

            2.辅助构造器的第一行代码必须是调用主构造器或者调用其他已经定义好的辅助构造器
</code></pre>
<h4 id="4-2-2-主构造器参数列表"><a href="#4-2-2-主构造器参数列表" class="headerlink" title="4.2.2 主构造器参数列表"></a>4.2.2 主构造器参数列表</h4><pre><code>        形式：

          1.参数名:类型  

          2.var 参数名:类型

          3.val 参数名:类型

          4.private val/var 参数名:类型

          5.@BeanProperty val/var 参数名:类型

        总结：

          1.当参数没有被修饰，且在类中没有使用该参数，该参数什么都不会生成。

          2.当参数被val修饰时，会生成private修饰的字段/属性，以及提供一个名字为参数名的公有取值方法。

          3.当参数被var修饰时，会生成private修饰的字段/属性，以及提供一个名字为参数名的公有取值方法和一个名字为参数名_=的公有赋值方法。

          4.与2,3生成的字段以及方法个数一致，不同在于生成的方法时私有的。

          5.@BeanProperty 会生成javaBean版本的set/get方法
</code></pre>
<h4 id="4-2-3-案例"><a href="#4-2-3-案例" class="headerlink" title="4.2.3:案例:"></a>4.2.3:案例:</h4><pre><code>     例1:构造器可以通过提供一个默认值来拥有可选参数：

        class Point(var x: Int = 0, var y: Int = 0)

        val origin = new Point  // x and y are both set to 0

        val point1 = new Point(1)

        println(point1.x)  // prints 1

     例2:在这个版本的Point类中，x和y拥有默认值0所以没有必传参数。然而，因为构造器是从左往右读取参数，所以如果仅仅要传个y的值，你需要带名传参。

        class Point(var x: Int = 0, var y: Int = 0)

        val point2 = new Point(y=2)

        println(point2.y)  // prints 2

    这样的做法在实践中有利于使得表达明确无误。
</code></pre>
<h3 id="4-3私有成员和Getter-Setter语法"><a href="#4-3私有成员和Getter-Setter语法" class="headerlink" title="4.3私有成员和Getter&#x2F;Setter语法"></a>4.3私有成员和Getter&#x2F;Setter语法</h3><pre><code>    成员默认是公有（public）的。使用private访问修饰符可以在函数外部隐藏它们。

    例1:

        class Point &#123;

          private var _x = 0

          private var _y = 0

          private val bound = 100

          def x = _x

          def x_= (newValue: Int): Unit = &#123;

            if (newValue &lt; bound) _x = newValue else printWarning

          &#125;

          def y = _y

          def y_= (newValue: Int): Unit = &#123;

            if (newValue &lt; bound) _y = newValue else printWarning

          &#125;

          private def printWarning = println(&quot;WARNING: Out of bounds&quot;)

        &#125;

        val point1 = new Point

        point1.x = 99

        point1.y = 101 // prints the warning

        在这个版本的Point类中，数据存在私有变量_x和_y中。def x和def y方法用于访问私有数据。def x_=和def y_=是为了验证和给_x和_y赋值。注意下对于setter方法的特殊语法：这个方法在getter方法的后面加上_=，后面跟着参数。

    例2:主构造方法中带有val和var的参数时公有的。然而由于val是不可变的，所以不能像下面这样去使用。

        class Point(val x: Int, val y: Int)

        val point = new Point(1, 2)

        point.x = 3  // &lt;-- does not compile

    例3:不带val或var的参数是私有的，仅在类中可见。

        class Point(x: Int, y: Int)

        val point = new Point(1, 2)

        point.x  // &lt;-- does not compile
</code></pre>
<h2 id="5-特质"><a href="#5-特质" class="headerlink" title="5.特质"></a>5.特质</h2><pre><code>特质 (Traits) 用于在类 (Class)之间共享程序接口 (Interface)和字段 (Fields)。 它们类似于Java 8的接口。 类和对象 (Objects)可以扩展特质，但是特质不能被实例化，因此特质没有参数。
</code></pre>
<h3 id="5-1定义特质"><a href="#5-1定义特质" class="headerlink" title="5.1定义特质:"></a>5.1定义特质:</h3><pre><code>    格式: trait 特质名 extends 类/特质 with 特质1 &#123;&#125;

    总结: 

        1.可以包含具体方法/属性

        2.可以包含抽象方法/属性

        3.特质 可以 混入 类/对象/特质/实例(对象)

    案例:

    	例1:最简化的特质就是关键字trait+标识符：

    		trait HairColor

    	例2:特征作为泛型类型和抽象方法非常有用。

    		trait Iterator[A] &#123;

              def hasNext: Boolean

              def next(): A

            &#125;

        扩展 trait Iterator [A] 需要一个类型 A 和实现方法hasNext和next。
</code></pre>
<h3 id="5-2使用特质"><a href="#5-2使用特质" class="headerlink" title="5.2使用特质:"></a>5.2使用特质:</h3><pre><code>    使用 extends 关键字来扩展特征。然后使用 override 关键字来实现trait里面的任何抽象成员：

        trait Iterator[A] &#123;

          def hasNext: Boolean

          def next(): A

        &#125;

        class IntIterator(to: Int) extends Iterator[Int] &#123;

          private var current = 0

          override def hasNext: Boolean = current &lt; to

          override def next(): Int =  &#123;

            if (hasNext) &#123;

              val t = current

              current += 1

              t

            &#125; else 0

          &#125;

        &#125;

        val iterator = new IntIterator(10)

        iterator.next()  // returns 0

        iterator.next()  // returns 1

    这个类 IntIterator 将参数 to 作为上限。它扩展了 Iterator [Int]，这意味着方法 next 必须返回一个Int。
</code></pre>
<h3 id="5-3子类型"><a href="#5-3子类型" class="headerlink" title="5.3子类型:"></a>5.3子类型:</h3><pre><code>    凡是需要特质的地方，都可以由该特质的子类型来替换。

    import scala.collection.mutable.ArrayBuffer

    trait Pet &#123;

      val name: String

    &#125;

    class Cat(val name: String) extends Pet

    class Dog(val name: String) extends Pet

    val dog = new Dog(&quot;Harry&quot;)

    val cat = new Cat(&quot;Sally&quot;)

    val animals = ArrayBuffer.empty[Pet]

    animals.append(dog)

    animals.append(cat)

    animals.foreach(pet =&gt; println(pet.name))  // Prints Harry Sally

    在这里 trait Pet 有一个抽象字段 name ，name 由Cat和Dog的构造函数中实现。最后一行，我们能调用pet.name的前提是它必须在特质Pet的子类型中得到了实现。
</code></pre>
<h2 id="6-元祖"><a href="#6-元祖" class="headerlink" title="6.元祖"></a>6.元祖</h2><pre><code>在 Scala 中，元组是一个可以容纳不同类型元素的类。 元组是不可变的。

当我们需要从函数返回多个值时，元组会派上用场。

元组可以创建如下：

    val ingredient = (&quot;Sugar&quot; , 25):Tuple2[String, Int]

这将创建一个包含一个 String 元素和一个 Int 元素的元组。

Scala 中的元组包含一系列类：Tuple2，Tuple3等，直到 Tuple22。 因此，当我们创建一个包含 n 个元素（n 位于 2 和 22 之间）的元组时，Scala 基本上就是从上述的一组类中实例化 一个相对应的类，使用组成元素的类型进行参数化。 上例中，ingredient 的类型为 Tuple2[String, Int]。
</code></pre>
<h3 id="6-1访问元素"><a href="#6-1访问元素" class="headerlink" title="6.1访问元素"></a>6.1访问元素</h3><pre><code>    使用下划线语法来访问元组中的元素。 ‘tuple._n’ 取出了第 n 个元素（假设有足够多元素）。

    println(ingredient._1) // Sugar

    println(ingredient._2) // 25
</code></pre>
<h3 id="6-2解构元组数据"><a href="#6-2解构元组数据" class="headerlink" title="6.2解构元组数据"></a>6.2解构元组数据</h3><pre><code>    Scala 元组也支持解构。

    val (name, quantity) = ingredient

    println(name) // Sugar

    println(quantity) // 25

    元组解构也可用于模式匹配。

    val planetDistanceFromSun = List((&quot;Mercury&quot;, 57.9), (&quot;Venus&quot;, 108.2), (&quot;Earth&quot;, 149.6 ), (&quot;Mars&quot;, 227.9), (&quot;Jupiter&quot;, 778.3))

    planetDistanceFromSun.foreach&#123; tuple =&gt; &#123;

      tuple match &#123;

          case (&quot;Mercury&quot;, distance) =&gt; println(s&quot;Mercury is $distance millions km far from Sun&quot;)

          case p if(p._1 == &quot;Venus&quot;) =&gt; println(s&quot;Venus is $&#123;p._2&#125; millions km far from Sun&quot;)

          case p if(p._1 == &quot;Earth&quot;) =&gt; println(s&quot;Blue planet is $&#123;p._2&#125; millions km far from Sun&quot;)

          case _ =&gt; println(&quot;Too far....&quot;)

        &#125;

      &#125;

    &#125;

    或者，在 ‘for’ 表达式中。

    val numPairs = List((2, 5), (3, -7), (20, 56))

    for ((a, b) &lt;- numPairs) &#123;

      println(a * b)

    &#125;

类型 Unit 的值 () 在概念上与类型 Tuple0 的值 () 相同。 Tuple0 只能有一个值，因为它没有元素。

用户有时可能在元组和 case 类之间难以选择。 通常，如果元素具有更多含义，则首选 case 类。
</code></pre>
<h2 id="7-通过混入（MIXIN）来组合类"><a href="#7-通过混入（MIXIN）来组合类" class="headerlink" title="7.通过混入（MIXIN）来组合类"></a>7.通过混入（MIXIN）来组合类</h2><pre><code>当某个特质被用于组合类时，被称为混入。

    abstract class A &#123;

      val message: String

    &#125;

    class B extends A &#123;

      val message = &quot;I&#39;m an instance of class B&quot;

    &#125;

    trait C extends A &#123;

      def loudMessage = message.toUpperCase()

    &#125;

    class D extends B with C

    val d = new D

    println(d.message)  // I&#39;m an instance of class B

    println(d.loudMessage)  // I&#39;M AN INSTANCE OF CLASS B

类D有一个父类B和一个混入C。一个类只能有一个父类但是可以有多个混入（分别使用关键字extend和with）。混入和某个父类可能有相同的父类。

现在，让我们看一个更有趣的例子，其中使用了抽象类：

    abstract class AbsIterator &#123;

      type T

      def hasNext: Boolean

      def next(): T

    &#125;

该类中有一个抽象的类型T和标准的迭代器方法。

接下来，我们将实现一个具体的类（所有的抽象成员T、hasNext和next都会被实现）：

    class StringIterator(s: String) extends AbsIterator &#123;

      type T = Char

      private var i = 0

      def hasNext = i &lt; s.length

      def next() = &#123;

        val ch = s charAt i

        i += 1

        ch

      &#125;

    &#125;

StringIterator带有一个String类型参数的构造器，可用于对字符串进行迭代。（例如查看一个字符串是否包含某个字符）：

现在我们创建一个特质，也继承于AbsIterator。

    trait RichIterator extends AbsIterator &#123;

      def foreach(f: T =&gt; Unit): Unit = while (hasNext) f(next())

    &#125;

该特质实现了foreach方法——只要还有元素可以迭代（while (hasNext)），就会一直对下个元素(next()) 调用传入的函数f: T =&gt; Unit。因为RichIterator是个特质，可以不必实现AbsIterator中的抽象成员。

下面我们要把StringIterator和RichIterator 中的功能组合成一个类。

    object StringIteratorTest extends App &#123;

      class RichStringIter extends StringIterator(&quot;Scala&quot;) with RichIterator

      val richStringIter = new RichStringIter

      richStringIter foreach println

    &#125;

新的类RichStringIter有一个父类StringIterator和一个混入RichIterator。如果是单一继承，我们将不会达到这样的灵活性。
</code></pre>
<h2 id="8-高阶函数"><a href="#8-高阶函数" class="headerlink" title="8.高阶函数"></a>8.高阶函数</h2><pre><code>高阶函数是指使用其他函数作为参数、或者返回一个函数作为结果的函数。在Scala中函数是&quot;一等公民&quot;，所以允许定义高阶函数。这里的术语可能有点让人困惑，我们约定，使用函数值作为参数，或者返回值为函数值的&quot;函数&quot;和&quot;方法&quot;，均称之为&quot;高阶函数&quot;。

最常见的一个例子是Scala集合类（collections）的高阶函数map

    val salaries = Seq(20000, 70000, 40000)

    val doubleSalary = (x: Int) =&gt; x * 2

    val newSalaries = salaries.map(doubleSalary) // List(40000, 140000, 80000)

函数doubleSalary有一个整型参数x，返回x * 2。一般来说，在=&gt;左边的元组是函数的参数列表，而右边表达式的值则为函数的返回值。在第3行，函数doubleSalary被应用在列表salaries中的每一个元素。

为了简化压缩代码，我们可以使用匿名函数，直接作为参数传递给map:

    val salaries = Seq(20000, 70000, 40000)

    val newSalaries = salaries.map(x =&gt; x * 2) // List(40000, 140000, 80000)

注意在上述示例中x没有被显式声明为Int类型，这是因为编译器能够根据map函数期望的类型推断出x的类型。对于上述代码，一种更惯用的写法为：

    val salaries = Seq(20000, 70000, 40000)

    val newSalaries = salaries.map(_ * 2)

既然Scala编译器已经知道了参数的类型（一个单独的Int），可以只给出函数的右半部分，不过需要使用_代替参数名（在上一个例子中是x）
</code></pre>
<h3 id="1-强制转换方法为函数"><a href="#1-强制转换方法为函数" class="headerlink" title="1.强制转换方法为函数"></a>1.强制转换方法为函数</h3><pre><code>    可以传入一个对象方法作为高阶函数的参数，这是因为Scala编译器会将方法强制转换为一个函数。

        case class WeeklyWeatherForecast(temperatures: Seq[Double]) &#123;

          private def convertCtoF(temp: Double) = temp * 1.8 + 32

          def forecastInFahrenheit: Seq[Double] = temperatures.map(convertCtoF) // &lt;-- passing the method convertCtoF

        &#125;

    在这个例子中，方法convertCtoF被传入forecastInFahrenheit。这是可以的，因为编译器强制将方法convertCtoF转成了函数x =&gt; convertCtoF(x) （注: x是编译器生成的变量名，保证在其作用域是唯一的）。
</code></pre>
<h3 id="2-接收函数作为参数的函数"><a href="#2-接收函数作为参数的函数" class="headerlink" title="2.接收函数作为参数的函数"></a>2.接收函数作为参数的函数</h3><pre><code>    使用高阶函数的一个原因是减少冗余的代码。比方说需要写几个方法以通过不同方式来提升员工工资，若不使用高阶函数，代码可能像这样：

        object SalaryRaiser &#123;

          def smallPromotion(salaries: List[Double]): List[Double] =

            salaries.map(salary =&gt; salary * 1.1)

          def greatPromotion(salaries: List[Double]): List[Double] =

            salaries.map(salary =&gt; salary * math.log(salary))

          def hugePromotion(salaries: List[Double]): List[Double] =

            salaries.map(salary =&gt; salary * salary)

        &#125;

    注意这三个方法的差异仅仅是提升的比例不同，为了简化代码，其实可以把重复的代码提到一个高阶函数中：

        object SalaryRaiser &#123;

          private def promotion(salaries: List[Double], promotionFunction: Double =&gt; Double): List[Double] =

            salaries.map(promotionFunction)

          def smallPromotion(salaries: List[Double]): List[Double] =

            promotion(salaries, salary =&gt; salary * 1.1)

          def bigPromotion(salaries: List[Double]): List[Double] =

            promotion(salaries, salary =&gt; salary * math.log(salary))

          def hugePromotion(salaries: List[Double]): List[Double] =

            promotion(salaries, salary =&gt; salary * salary)

        &#125;

    新的方法promotion有两个参数，薪资列表和一个类型为Double =&gt; Double的函数（参数和返回值类型均为Double），返回薪资提升的结果。
</code></pre>
<h3 id="3-返回函数的函数"><a href="#3-返回函数的函数" class="headerlink" title="3.返回函数的函数"></a>3.返回函数的函数</h3><pre><code>    有一些情况你希望生成一个函数， 比如：

        def urlBuilder(ssl: Boolean, domainName: String): (String, String) =&gt; String = &#123;

          val schema = if (ssl) &quot;https://&quot; else &quot;http://&quot;

          (endpoint: String, query: String) =&gt; s&quot;$schema$domainName/$endpoint?$query&quot;

        &#125;

        val domainName = &quot;www.example.com&quot;

        def getURL = urlBuilder(ssl=true, domainName)

        val endpoint = &quot;users&quot;

        val query = &quot;id=1&quot;

        val url = getURL(endpoint, query) // &quot;https://www.example.com/users?id=1&quot;: String

    注意urlBuilder的返回类型是(String, String) =&gt; String，这意味着返回的匿名函数有两个String参数，返回一个String。在这个例子中，返回的匿名函数是(endpoint: String, query: String) =&gt; s&quot;https://www.example.com/$endpoint?$query&quot;。
</code></pre>
<h2 id="9-嵌套方法"><a href="#9-嵌套方法" class="headerlink" title="9.嵌套方法"></a>9.嵌套方法</h2><pre><code>在Scala中可以嵌套定义方法。例如以下对象提供了一个factorial方法来计算给定数值的阶乘：

     def factorial(x: Int): Int = &#123;

        def fact(x: Int, accumulator: Int): Int = &#123;

          if (x &lt;= 1) accumulator

          else fact(x - 1, x * accumulator)

        &#125;  

        fact(x, 1)

     &#125;

     println(&quot;Factorial of 2: &quot; + factorial(2))

     println(&quot;Factorial of 3: &quot; + factorial(3))

程序的输出为:

    Factorial of 2: 2

    Factorial of 3: 6
</code></pre>
<h2 id="10-多参数列表（柯里化）"><a href="#10-多参数列表（柯里化）" class="headerlink" title="10.多参数列表（柯里化）"></a>10.多参数列表（柯里化）</h2><pre><code>方法可以定义多个参数列表，当使用较少的参数列表调用多参数列表的方法时，会产生一个新的函数，该函数接收剩余的参数列表作为其参数。这被称为柯里化。

下面是一个例子，在Scala集合中定义的特质Traversable：

    def foldLeft[B](z: B)(op: (B, A) =&gt; B): B

foldLeft从左到右，以此将一个二元运算op应用到初始值z和该迭代器（traversable)的所有元素上。以下是该函数的一个用例：

从初值0开始, 这里 foldLeft 将函数 (m, n) =&gt; m + n 依次应用到列表中的每一个元素和之前累积的值上。

    val numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

    val res = numbers.foldLeft(0)((m, n) =&gt; m + n)

    print(res) // 55

多参数列表有更复杂的调用语法，因此应该谨慎使用，建议的使用场景包括：

    单一的函数参数

        在某些情况下存在单一的函数参数时，例如上述例子foldLeft中的op，多参数列表可以使得传递匿名函数作为参数的语法更为简洁。如果不使用多参数列表，代码可能像这样：

            numbers.foldLeft(0, &#123;(m: Int, n: Int) =&gt; m + n&#125;)

        注意使用多参数列表时，我们还可以利用Scala的类型推断来让代码更加简洁（如下所示），而如果没有多参数列表，这是不可能的。

            numbers.foldLeft(0)(_ + _)

        像上述语句这样，我们可以给定多参数列表的一部分参数列表（如上述的z）来形成一个新的函数（partially applied function），达到复用的目的，如下所示：

            val numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

            val numberFunc = numbers.foldLeft(List[Int]())_

            val squares = numberFunc((xs, x) =&gt; xs:+ x*x)

            print(squares.toString()) // List(1, 4, 9, 16, 25, 36, 49, 64, 81, 100)

            val cubes = numberFunc((xs, x) =&gt; xs:+ x*x*x)

            print(cubes.toString())  // List(1, 8, 27, 64, 125, 216, 343, 512, 729, 1000)

        最后，foldLeft 和 foldRight 可以按以下任意一种形式使用，

            val numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

            numbers.foldLeft(0)((sum, item) =&gt; sum + item) // Generic Form

            numbers.foldRight(0)((sum, item) =&gt; sum + item) // Generic Form

            numbers.foldLeft(0)(_+_) // Curried Form

            numbers.foldRight(0)(_+_) // Curried Form

            (0 /: numbers)(_+_) // Used in place of foldLeft

            (numbers :\ 0)(_+_) // Used in place of foldRight

    隐式（IMPLICIT）参数

        如果要指定参数列表中的某些参数为隐式（implicit），应该使用多参数列表。例如：

        def execute(arg: Int)(implicit ec: ExecutionContext) = ???
</code></pre>
<h2 id="11-单例对象"><a href="#11-单例对象" class="headerlink" title="11.单例对象"></a>11.单例对象</h2><pre><code>单例对象是一种特殊的类，有且只有一个实例。和惰性变量一样，单例对象是延迟创建的，当它第一次被使用时创建。

当对象定义于顶层时(即没有包含在其他类中)，单例对象只有一个实例。

当对象定义在一个类或方法中时，单例对象表现得和惰性变量一样。
</code></pre>
<h3 id="1-定义一个单例对象"><a href="#1-定义一个单例对象" class="headerlink" title="1.定义一个单例对象"></a>1.定义一个单例对象</h3><pre><code>    一个单例对象是就是一个值。单例对象的定义方式很像类，但是使用关键字 object：

        object Box

    下面例子中的单例对象包含一个方法：

        package logging

        object Logger &#123;

          def info(message: String): Unit = println(s&quot;INFO: $message&quot;)

        &#125;

    方法 info 可以在程序中的任何地方被引用。像这样创建功能性方法是单例对象的一种常见用法。

    下面让我们来看看如何在另外一个包中使用 info 方法：

        import logging.Logger.info

        class Project(name: String, daysToComplete: Int)

        class Test &#123;

          val project1 = new Project(&quot;TPS Reports&quot;, 1)

          val project2 = new Project(&quot;Website redesign&quot;, 5)

          info(&quot;Created projects&quot;)  // Prints &quot;INFO: Created projects&quot;

        &#125;

    因为 import 语句 import logging.Logger.info，方法 info 在此处是可见的。

    import语句要求被导入的标识具有一个&quot;稳定路径&quot;，一个单例对象由于全局唯一，所以具有稳定路径。

    注意：如果一个 object 没定义在顶层而是定义在另一个类或者单例对象中，那么这个单例对象和其他类普通成员一样是&quot;路径相关的&quot;。这意味着有两种行为，class Milk 和 class OrangeJuice，一个类成员 object NutritionInfo &quot;依赖&quot;于包装它的实例，要么是牛奶要么是橙汁。 milk.NutritionInfo 则完全不同于oj.NutritionInfo。
</code></pre>
<h3 id="2-伴生对象"><a href="#2-伴生对象" class="headerlink" title="2.伴生对象"></a>2.伴生对象</h3><pre><code>    当一个单例对象和某个类共享一个名称时，这个单例对象称为 伴生对象。 同理，这个类被称为是这个单例对象的伴生类。类和它的伴生对象可以互相访问其私有成员。使用伴生对象来定义那些在伴生类中不依赖于实例化对象而存在的成员变量或者方法。

        import scala.math._

        case class Circle(radius: Double) &#123;

          import Circle._

          def area: Double = calculateArea(radius)

        &#125;

        object Circle &#123;

          private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)

        &#125;

        val circle1 = new Circle(5.0)

        circle1.area

    这里的 class Circle 有一个成员 area 是和具体的实例化对象相关的，单例对象 object Circle 包含一个方法 calculateArea ，它在每一个实例化对象中都是可见的。

    伴生对象也可以包含工厂方法：

        class Email(val username: String, val domainName: String)

        object Email &#123;

          def fromString(emailString: String): Option[Email] = &#123;

            emailString.split(&#39;@&#39;) match &#123;

              case Array(a, b) =&gt; Some(new Email(a, b))

              case _ =&gt; None

            &#125;

          &#125;

        &#125;

        val scalaCenterEmail = Email.fromString(&quot;scala.center@epfl.ch&quot;)

        scalaCenterEmail match &#123;

          case Some(email) =&gt; println(

            s&quot;&quot;&quot;Registered an email

               |Username: $&#123;email.username&#125;

               |Domain name: $&#123;email.domainName&#125;

             &quot;&quot;&quot;)

          case None =&gt; println(&quot;Error: could not parse email&quot;)

        &#125;

    伴生对象 object Email 包含有一个工厂方法 fromString 用来根据一个 String 创建 Email 实例。在这里我们返回的是 Option[Email] 以防有语法分析错误。

    注意：类和它的伴生对象必须定义在同一个源文件里。如果需要在 REPL 里定义类和其伴生对象，需要将它们定义在同一行或者进入 :paste 模式。
</code></pre>
<h3 id="3-Java-程序员的注意事项"><a href="#3-Java-程序员的注意事项" class="headerlink" title="3.Java 程序员的注意事项"></a>3.Java 程序员的注意事项</h3><pre><code>    在 Java 中 static 成员对应于 Scala 中的伴生对象的普通成员。

    在 Java 代码中调用伴生对象时，伴生对象的成员会被定义成伴生类中的 static 成员。这称为 静态转发。这种行为发生在当你自己没有定义一个伴生类时。
</code></pre>
<h2 id="12-正则表达式"><a href="#12-正则表达式" class="headerlink" title="12.正则表达式"></a>12.正则表达式</h2><pre><code>正则表达式是一类特殊的字符串，可以用来在数据中寻找特定模式。 任何字符串都可以通过调用 .r 方法来转换成正则表达式。

    import scala.util.matching.Regex

    val numberPattern: Regex = &quot;[0-9]&quot;.r

    numberPattern.findFirstMatchIn(&quot;awesomepassword&quot;) match &#123;

      case Some(_) =&gt; println(&quot;Password OK&quot;)

      case None =&gt; println(&quot;Password must contain a number&quot;)

    &#125;

在上例中，常量 numberPattern 是一个 Regex 类型的实例（正则表达式），这里用来确保密码中含有一个数字。

你也可以用圆括号括起多个正则表达式，以便一次寻找多个值。

    import scala.util.matching.Regex

    val keyValPattern: Regex = &quot;([0-9a-zA-Z-#() ]+): ([0-9a-zA-Z-#() ]+)&quot;.r

    val input: String =

      &quot;&quot;&quot;background-color: #A03300;

        |background-image: url(img/header100.png);

        |background-position: top center;

        |background-repeat: repeat-x;

        |background-size: 2160px 108px;

        |margin: 0;

        |height: 108px;

        |width: 100%;&quot;&quot;&quot;.stripMargin

    for (patternMatch &lt;- keyValPattern.findAllMatchIn(input))

      println(s&quot;key: $&#123;patternMatch.group(1)&#125; value: $&#123;patternMatch.group(2)&#125;&quot;)

  此例中我们从字符串中解析出多组键值对。每一个匹配值都包含一组子匹配值。结果如下：

    key: background-color value: #A03300

    key: background-image value: url(img

    key: background-position value: top center

    key: background-repeat value: repeat-x

    key: background-size value: 2160px 108px

    key: margin value: 0

    key: height value: 108px

    key: width value: 100
</code></pre>
<h2 id="13-提取器对象"><a href="#13-提取器对象" class="headerlink" title="13.提取器对象"></a>13.提取器对象</h2><pre><code>提取器对象是一个包含有 unapply 方法的单例对象。apply 方法就像一个构造器，接受参数然后创建一个实例对象，反之 unapply 方法接受一个实例对象然后返回最初创建它所用的参数。提取器常用在模式匹配和偏函数中。

    import scala.util.Random

    object CustomerID &#123;

      def apply(name: String) = s&quot;$name--$&#123;Random.nextLong&#125;&quot;

      def unapply(customerID: String): Option[String] = &#123;

        val stringArray: Array[String] = customerID.split(&quot;--&quot;)

        if (stringArray.tail.nonEmpty) Some(stringArray.head) else None

      &#125;

    &#125;

    val customer1ID = CustomerID(&quot;Sukyoung&quot;)  // Sukyoung--23098234908

    customer1ID match &#123;

      case CustomerID(name) =&gt; println(name)  // prints Sukyoung

      case _ =&gt; println(&quot;Could not extract a CustomerID&quot;)

    &#125;

这里 apply 方法用 name 创建一个 CustomerID 字符串。而 unapply 方法正好相反，它返回 name 。当我们调用 CustomerID(&quot;Sukyoung&quot;) ，其实是调用了 CustomerID.apply(&quot;Sukyoung&quot;) 的简化语法。当我们调用 case CustomerID(name) =&gt; println(name)，就是在调用提取器方法。

因为变量定义可以使用模式引入变量，提取器可以用来初始化这个变量，使用 unapply 方法来生成值。

    val customer2ID = CustomerID(&quot;Nico&quot;)

    val CustomerID(name) = customer2ID

    println(name)  // prints Nico

上面的代码等价于 val name = CustomerID.unapply(customer2ID).get。

    val CustomerID(name2) = &quot;--asdfasdfasdf&quot;

如果没有匹配的值，会抛出 scala.MatchError：

    val CustomerID(name3) = &quot;-asdfasdfasdf&quot;

unapply 方法的返回值应当符合下面的某一条：

    如果只是用来判断真假，可以返回一个 Boolean 类型的值。例如 case even()。

    如果只是用来提取单个 T 类型的值，可以返回 Option[T]。

    如果你想要提取多个值，类型分别为 T1,...,Tn，可以把它们放在一个可选的元组中 Option[(T1,...,Tn)]。

有时，要提取的值的数量不是固定的，因此我们想根据输入来返回随机数量的值。这种情况下，你可以用 unapplySeq 方法来定义提取器，此方法返回 Option[Seq[T]]。常见的例子有，用 case List(x, y, z) =&gt; 来解构一个列表 List，以及用一个正则表达式 Regex 来分解一个字符串 String，例如 case r(name, remainingFields @ _*) =&gt;。
</code></pre>
<h2 id="14-FOR-表达式"><a href="#14-FOR-表达式" class="headerlink" title="14.FOR 表达式"></a>14.FOR 表达式</h2><pre><code>Scala 提供一个轻量级的标记方式用来表示 序列推导。推导使用形式为 for (enumerators) yield e 的 for 表达式，此处 enumerators 指一组以分号分隔的枚举器。一个 enumerator 要么是一个产生新变量的生成器，要么是一个过滤器。for 表达式在枚举器产生的每一次绑定中都会计算 e 值，并在循环结束后返回这些值组成的序列。

看下例：

    case class User(name: String, age: Int)

    val userBase = List(User(&quot;Travis&quot;, 28),

      User(&quot;Kelly&quot;, 33),

      User(&quot;Jennifer&quot;, 44),

      User(&quot;Dennis&quot;, 23))

    val twentySomethings = for (user &lt;- userBase if (user.age &gt;=20 &amp;&amp; user.age &lt; 30))

      yield user.name  // i.e. add this to a list

    twentySomethings.foreach(name =&gt; println(name))  // prints Travis Dennis

这里 for 循环后面使用的 yield 语句实际上会创建一个 List。因为当我们说 yield user.name 的时候，它实际上是一个 List[String]。 user &lt;- userBase 是生成器，if (user.age &gt;=20 &amp;&amp; user.age &lt; 30) 是过滤器用来过滤掉那些年龄不是20多岁的人。

下面这个例子复杂一些，使用了两个生成器。它计算了 0 到 n-1 的所有两两求和为 v 的数字的组合：

    def foo(n: Int, v: Int) =

       for (i &lt;- 0 until n;

            j &lt;- i until n if i + j == v)

       yield (i, j)

    foo(10, 10) foreach &#123;

      case (i, j) =&gt;

        println(s&quot;($i, $j) &quot;)  // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5)

    &#125;

这里 n == 10 和 v == 10。在第一次迭代时，i == 0 并且 j == 0 所以 i + j != v 因此没有返回值被生成。在 i 的值递增到 1 之前，j 的值又递增了 9 次。如果没有 if 语句过滤，上面的例子只会打印出如下的结果：

    (0, 0) (0, 1) (0, 2) (0, 3) (0, 4) (0, 5) (0, 6) (0, 7) (0, 8) (0, 9) (1, 1) ...

注意 for 表达式并不局限于使用列表。任何数据类型只要支持 withFilter，map，和 flatMap 操作（不同数据类型可能支持不同的操作）都可以用来做序列推导。

你可以在使用 for 表达式时省略 yield 语句。此时会返回 Unit。当你想要执行一些副作用的时候这很有用。下面的例子输出和上面相同的结果，但是没有使用 yield：

    def foo(n: Int, v: Int) =

       for (i &lt;- 0 until n;

            j &lt;- i until n if i + j == v)

       println(s&quot;($i, $j)&quot;)

    foo(10, 10)
</code></pre>
<h2 id="15-泛型类"><a href="#15-泛型类" class="headerlink" title="15.泛型类"></a>15.泛型类</h2><pre><code>泛型类指可以接受类型参数的类。泛型类在集合类中被广泛使用。
</code></pre>
<h3 id="1-定义一个泛型类"><a href="#1-定义一个泛型类" class="headerlink" title="1.定义一个泛型类"></a>1.定义一个泛型类</h3><pre><code>    泛型类使用方括号 [] 来接受类型参数。一个惯例是使用字母 A 作为参数标识符，当然你可以使用任何参数名称。

        class Stack[A] &#123;

          private var elements: List[A] = Nil

          def push(x: A) &#123; elements = x :: elements &#125;

          def peek: A = elements.head

          def pop(): A = &#123;

            val currentTop = peek

            elements = elements.tail

            currentTop

          &#125;

        &#125;

    上面的 Stack 类的实现中接受类型参数 A。 这表示其内部的列表，var elements: List[A] = Nil，只能够存储类型 A 的元素。方法 def push 只接受类型 A 的实例对象作为参数(注意：elements = x :: elements 将 elements 放到了一个将元素 x 添加到 elements 的头部而生成的新列表中)。
</code></pre>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><pre><code>    要使用一个泛型类，将一个具体类型放到方括号中来代替 A。

        val stack = new Stack[Int]

        stack.push(1)

        stack.push(2)

        println(stack.pop)  // prints 2

        println(stack.pop)  // prints 1

    实例对象 stack 只能接受整型值。然而，如果类型参数有子类型，子类型可以被传入：

        class Fruit

        class Apple extends Fruit

        class Banana extends Fruit

        val stack = new Stack[Fruit]

        val apple = new Apple

        val banana = new Banana

        stack.push(apple)

        stack.push(banana)

    类 Apple 和类 Banana 都继承自类 Fruit，所以我们可以把实例对象 apple 和 banana 压入栈 Fruit 中。

    注意：泛型类型的子类型是*不可传导*的。这表示如果我们有一个字母类型的栈 Stack[Char]，那它不能被用作一个整型的栈 Stack[Int]。否则就是不安全的，因为它将使我们能够在字母型的栈中插入真正的整型值。结论就是，只有当类型 B = A 时， Stack[A] 是 Stack[B] 的子类型才成立。因为此处可能会有很大的限制，Scala 提供了一种 类型参数注释机制 用以控制泛型类型的子类型的行为。
</code></pre>
<h2 id="16-型变"><a href="#16-型变" class="headerlink" title="16.型变"></a>16.型变</h2><pre><code>型变是复杂类型的子类型关系与其组件类型的子类型关系的相关性。 Scala支持 泛型类 的类型参数的型变注释，允许它们是协变的，逆变的，或在没有使用注释的情况下是不变的。 在类型系统中使用型变允许我们在复杂类型之间建立直观的连接，而缺乏型变则会限制类抽象的重用性。

    class Foo[+A] // A covariant class

    class Bar[-A] // A contravariant class

    class Baz[A]  // An invariant class
</code></pre>
<h3 id="1-协变"><a href="#1-协变" class="headerlink" title="1.协变"></a>1.协变</h3><pre><code>    使用注释 +A，可以使一个泛型类的类型参数 A 成为协变。 对于某些类 class List[+A]，使 A 成为协变意味着对于两种类型 A 和 B，如果 A 是 B 的子类型，那么 List[A] 就是 List[B] 的子类型。 这允许我们使用泛型来创建非常有用和直观的子类型关系。

    考虑以下简单的类结构：

        abstract class Animal &#123;

          def name: String

        &#125;

        case class Cat(name: String) extends Animal

        case class Dog(name: String) extends Animal

    类型 Cat 和 Dog 都是 Animal 的子类型。 Scala 标准库有一个通用的不可变的类 sealed abstract class List[+A]，其中类型参数 A 是协变的。 这意味着 List[Cat] 是 List[Animal]，List[Dog] 也是 List[Animal]。 直观地说，猫的列表和狗的列表都是动物的列表是合理的，你应该能够用它们中的任何一个替换 List[Animal]。

    在下例中，方法 printAnimalNames 将接受动物列表作为参数，并且逐行打印出它们的名称。 如果 List[A] 不是协变的，最后两个方法调用将不能编译，这将严重限制 printAnimalNames 方法的适用性。

        object CovarianceTest extends App &#123;

          def printAnimalNames(animals: List[Animal]): Unit = &#123;

            animals.foreach &#123; animal =&gt;

              println(animal.name)

            &#125;

          &#125;

          val cats: List[Cat] = List(Cat(&quot;Whiskers&quot;), Cat(&quot;Tom&quot;))

          val dogs: List[Dog] = List(Dog(&quot;Fido&quot;), Dog(&quot;Rex&quot;))

          printAnimalNames(cats)

          // Whiskers

          // Tom

          printAnimalNames(dogs)

          // Fido

          // Rex

        &#125;
</code></pre>
<h3 id="2-逆变"><a href="#2-逆变" class="headerlink" title="2.逆变"></a>2.逆变</h3><pre><code>    通过使用注释 -A，可以使一个泛型类的类型参数 A 成为逆变。 与协变类似，这会在类及其类型参数之间创建一个子类型关系，但其作用与协变完全相反。 也就是说，对于某个类 class Writer[-A] ，使 A 逆变意味着对于两种类型 A 和 B，如果 A 是 B 的子类型，那么 Writer[B] 是 Writer[A] 的子类型。

    考虑在下例中使用上面定义的类 Cat，Dog 和 Animal ：

        abstract class Printer[-A] &#123;

          def print(value: A): Unit

        &#125;

        这里 Printer[A] 是一个简单的类，用来打印出某种类型的 A。 让我们定义一些特定的子类：

        class AnimalPrinter extends Printer[Animal] &#123;

          def print(animal: Animal): Unit =

            println(&quot;The animal&#39;s name is: &quot; + animal.name)

        &#125;

        class CatPrinter extends Printer[Cat] &#123;

          def print(cat: Cat): Unit =

            println(&quot;The cat&#39;s name is: &quot; + cat.name)

        &#125;

    如果 Printer[Cat] 知道如何在控制台打印出任意 Cat，并且 Printer[Animal] 知道如何在控制台打印出任意 Animal，那么 Printer[Animal] 也应该知道如何打印出 Cat 就是合理的。 反向关系不适用，因为 Printer[Cat] 并不知道如何在控制台打印出任意 Animal。 因此，如果我们愿意，我们应该能够用 Printer[Animal] 替换 Printer[Cat]，而使 Printer[A] 逆变允许我们做到这一点。

        object ContravarianceTest extends App &#123;

          val myCat: Cat = Cat(&quot;Boots&quot;)

          def printMyCat(printer: Printer[Cat]): Unit = &#123;

            printer.print(myCat)

          &#125;

          val catPrinter: Printer[Cat] = new CatPrinter

          val animalPrinter: Printer[Animal] = new AnimalPrinter

          printMyCat(catPrinter)

          printMyCat(animalPrinter)

        &#125;

    这个程序的输出如下：

        The cat&#39;s name is: Boots

        The animal&#39;s name is: Boots
</code></pre>
<h3 id="3-不变"><a href="#3-不变" class="headerlink" title="3.不变"></a>3.不变</h3><pre><code>    默认情况下，Scala中的泛型类是不变的。 这意味着它们既不是协变的也不是逆变的。 在下例中，类 Container 是不变的。 Container[Cat] 不是 Container[Animal]，反之亦然。

        class Container[A](value: A) &#123;

          private var _value: A = value

          def getValue: A = _value

          def setValue(value: A): Unit = &#123;

            _value = value

          &#125;

        &#125;

    可能看起来一个 Container[Cat] 自然也应该是一个 Container[Animal]，但允许一个可变的泛型类成为协变并不安全。 在这个例子中，Container 是不变的非常重要。 假设 Container 实际上是协变的，下面的情况可能会发生：

        val catContainer: Container[Cat] = new Container(Cat(&quot;Felix&quot;))

        val animalContainer: Container[Animal] = catContainer

        animalContainer.setValue(Dog(&quot;Spot&quot;))

        val cat: Cat = catContainer.getValue // 糟糕，我们最终会将一只狗作为值分配给一只猫

    幸运的是，编译器在此之前就会阻止我们。
</code></pre>
<h3 id="4-其他例子"><a href="#4-其他例子" class="headerlink" title="4.其他例子"></a>4.其他例子</h3><pre><code>    另一个可以帮助理解型变的例子是 Scala 标准库中的 trait Function1[-T, +R]。 Function1 表示具有一个参数的函数，其中第一个类型参数 T 表示参数类型，第二个类型参数 R 表示返回类型。 Function1 在其参数类型上是逆变的，并且在其返回类型上是协变的。 对于这个例子，我们将使用文字符号 A =&gt; B 来表示 Function1[A, B]。

    假设前面使用过的类似 Cat，Dog，Animal 的继承关系，加上以下内容：

        abstract class SmallAnimal extends Animal

        case class Mouse(name: String) extends SmallAnimal

    假设我们正在处理接受动物类型的函数，并返回他们的食物类型。 如果我们想要一个 Cat =&gt; SmallAnimal（因为猫吃小动物），但是给它一个 Animal =&gt; Mouse，我们的程序仍然可以工作。 直观地看，一个 Animal =&gt; Mouse 的函数仍然会接受一个 Cat 作为参数，因为 Cat 即是一个 Animal，并且这个函数返回一个 Mouse，也是一个 SmallAnimal。 既然我们可以安全地，隐式地用前者代替后者，我们可以说 Animal =&gt; Mouse 是 Cat =&gt; SmallAnimal 的子类型。
</code></pre>
<h3 id="5-与其他语言的比较"><a href="#5-与其他语言的比较" class="headerlink" title="5.与其他语言的比较"></a>5.与其他语言的比较</h3><pre><code>    某些与 Scala 类似的语言以不同的方式支持型变。 例如，Scala 中的型变注释与 C# 中的非常相似，在定义类抽象时添加型变注释（声明点型变）。 但是在Java中，当类抽象被使用时（使用点型变），才会给出型变注释。
</code></pre>
<h2 id="17-类型上界"><a href="#17-类型上界" class="headerlink" title="17.类型上界"></a>17.类型上界</h2><pre><code>在Scala中，类型参数和抽象类型都可以有一个类型边界约束。这种类型边界在限制类型变量实际取值的同时还能展露类型成员的更多信息。比如像T &lt;: A这样声明的类型上界表示类型变量T应该是类型A的子类。下面的例子展示了类PetContainer的一个类型参数的类型上界。

    abstract class Animal &#123;

     def name: String

    &#125;

    abstract class Pet extends Animal &#123;&#125;

    class Cat extends Pet &#123;

      override def name: String = &quot;Cat&quot;

    &#125;

    class Dog extends Pet &#123;

      override def name: String = &quot;Dog&quot;

    &#125;

    class Lion extends Animal &#123;

      override def name: String = &quot;Lion&quot;

    &#125;

    class PetContainer[P &lt;: Pet](p: P) &#123;

      def pet: P = p

    &#125;

    val dogContainer = new PetContainer[Dog](new Dog)

    val catContainer = new PetContainer[Cat](new Cat)

    // this would not compile

    val lionContainer = new PetContainer[Lion](new Lion)

类PetContainer接受一个必须是Pet子类的类型参数P。因为Dog和Cat都是Pet的子类，所以可以构造PetContainer[Dog]和PetContainer[Cat]。但在尝试构造PetContainer[Lion]的时候会得到下面的错误信息：

    type arguments [Lion] do not conform to class PetContainer&#39;s type parameter bounds [P &lt;: Pet]

这是因为Lion并不是Pet的子类。
</code></pre>
<h2 id="18-类型下界"><a href="#18-类型下界" class="headerlink" title="18.类型下界"></a>18.类型下界</h2><pre><code>类型上界 将类型限制为另一种类型的子类型，而 类型下界 将类型声明为另一种类型的超类型。 术语 B &gt;: A 表示类型参数 B 或抽象类型 B 是类型 A 的超类型。 在大多数情况下，A 将是类的类型参数，而 B 将是方法的类型参数。

下面看一个适合用类型下界的例子：

    trait Node[+B] &#123;

      def prepend(elem: B): Node[B]

    &#125;

    case class ListNode[+B](h: B, t: Node[B]) extends Node[B] &#123;

      def prepend(elem: B): ListNode[B] = ListNode(elem, this)

      def head: B = h

      def tail: Node[B] = t

    &#125;

    case class Nil[+B]() extends Node[B] &#123;

      def prepend(elem: B): ListNode[B] = ListNode(elem, this)

    &#125;

该程序实现了一个单链表。 Nil 表示空元素（即空列表）。 class ListNode 是一个节点，它包含一个类型为 B (head) 的元素和一个对列表其余部分的引用 (tail)。 class Node 及其子类型是协变的，因为我们定义了 +B。

但是，这个程序 不能 编译，因为方法 prepend 中的参数 elem 是协变的 B 类型。 这会出错，因为函数的参数类型是逆变的，而返回类型是协变的。

要解决这个问题，我们需要将方法 prepend 的参数 elem 的型变翻转。 我们通过引入一个新的类型参数 U 来实现这一点，该参数具有 B 作为类型下界。

    trait Node[+B] &#123;

      def prepend[U &gt;: B](elem: U): Node[U]

    &#125;

    case class ListNode[+B](h: B, t: Node[B]) extends Node[B] &#123;

      def prepend[U &gt;: B](elem: U): ListNode[U] = ListNode(elem, this)

      def head: B = h

      def tail: Node[B] = t

    &#125;

    case class Nil[+B]() extends Node[B] &#123;

      def prepend[U &gt;: B](elem: U): ListNode[U] = ListNode(elem, this)

    &#125;

现在我们像下面这么做：

    trait Bird

    case class AfricanSwallow() extends Bird

    case class EuropeanSwallow() extends Bird

    val africanSwallowList= ListNode[AfricanSwallow](AfricanSwallow(), Nil())

    val birdList: Node[Bird] = africanSwallowList

    birdList.prepend(new EuropeanSwallow)

可以为 Node[Bird] 赋值 africanSwallowList，然后再加入一个 EuropeanSwallow。
</code></pre>

    </div>

    
    
    
        <div class="reward-container">
  <div>原创技术分享，您的支持将鼓励我继续创作</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Qzhang 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Qzhang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://jackzhangqing.github.io/2023/09/02/Scala%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/" title="Scala官方文档">https://jackzhangqing.github.io/2023/09/02/Scala官方文档/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Scala%E6%96%87%E6%A1%A3/" rel="tag"># Scala文档</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/09/02/32%E4%B8%AA%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/" rel="prev" title="32个经典算法">
      <i class="fa fa-chevron-left"></i> 32个经典算法
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/09/02/%E5%8F%91%E6%96%87%E7%AB%A0/" rel="next" title="发文章">
      发文章 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">1.介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFScala"><span class="nav-number">1.1.</span> <span class="nav-text">1.什么是Scala</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Scala%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="nav-number">1.2.</span> <span class="nav-text">2.Scala是面向对象编程语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Scala%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="nav-number">1.3.</span> <span class="nav-text">3.Scala是函数式编程语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Scala%E6%98%AF%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E7%9A%84"><span class="nav-number">1.4.</span> <span class="nav-text">4.Scala是静态类型的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Scala%E6%98%AF%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84"><span class="nav-number">1.5.</span> <span class="nav-text">5.Scala是可扩展的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Scala%E4%BA%92%E6%93%8D%E4%BD%9C"><span class="nav-number">1.6.</span> <span class="nav-text">6.Scala互操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">2.基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%98%AF%E5%8F%AF%E8%AE%A1%E7%AE%97%E8%AF%AD%E5%8F%A5%E3%80%82"><span class="nav-number">2.1.</span> <span class="nav-text">2.1表达式:表达式是可计算语句。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E5%9D%97-%E7%BB%84%E5%90%88%E5%87%A0%E4%B8%AA%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%B9%B6%E4%B8%94%E7%94%A8-%E5%8C%85%E8%A3%B9%E7%9A%84%E7%A7%B0%E4%B9%8B%E4%B8%BA%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%82%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%AD%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%9C%E4%B9%9F%E6%98%AF%E6%95%B4%E4%B8%AA%E5%9D%97%E7%9A%84%E7%BB%93%E6%9E%9C%E3%80%82"><span class="nav-number">2.2.</span> <span class="nav-text">2.2块: 组合几个表达式,并且用{}包裹的称之为代码块。代码块中最后一个表达式的结果也是整个块的结果。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3%E5%87%BD%E6%95%B0-%E5%87%BD%E6%95%B0%E6%98%AF%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%82"><span class="nav-number">2.3.</span> <span class="nav-text">2.3函数:函数是带参数的表达式。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4%E6%96%B9%E6%B3%95-%E6%96%B9%E6%B3%95%E7%9C%8B%E8%B5%B7%E6%9D%A5%E5%92%8C%E8%A1%8C%E4%B8%BA%E4%B8%8E%E5%87%BD%E6%95%B0%E9%9D%9E%E5%B8%B8%E7%9B%B8%E4%BC%BC%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="nav-number">2.4.</span> <span class="nav-text">2.4方法:方法看起来和行为与函数非常相似，但是它们之间有几个关键的区别。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5%E7%B1%BB-%E5%8F%AF%E4%BB%A5%E7%94%A8class%E5%85%B3%E9%94%AE%E5%AD%97%E6%9D%A5%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%B1%BB%EF%BC%8C%E5%90%8E%E9%9D%A2%E8%B7%9F%E7%9D%80%E5%AE%83%E7%9A%84%E5%90%8D%E5%AD%97%E5%92%8C%E6%9E%84%E9%80%A0%E5%99%A8%E3%80%82"><span class="nav-number">2.5.</span> <span class="nav-text">2.5类:可以用class关键字来定义一个类，后面跟着它的名字和构造器。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6%E6%A0%B7%E4%BE%8B%E7%B1%BB-Scala%E6%9C%89%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E7%B1%BB%E5%8F%AB%E5%81%9A%E6%A0%B7%E4%BE%8B%E7%B1%BB%EF%BC%88case-class%EF%BC%89%E3%80%82%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E6%A0%B7%E4%BE%8B%E7%B1%BB%E4%B8%80%E8%88%AC%E7%94%A8%E4%BA%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%8F%AF%E4%BD%9C%E5%80%BC%E6%AF%94%E8%BE%83%E3%80%82%E4%BD%A0%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8case-class%E5%85%B3%E9%94%AE%E5%AD%97%E6%9D%A5%E5%AE%9A%E4%B9%89%E6%A0%B7%E4%BE%8B%E7%B1%BB%E3%80%82"><span class="nav-number">2.6.</span> <span class="nav-text">2.6样例类:Scala有一种特殊的类叫做样例类（case class）。默认情况下，样例类一般用于不可变对象，并且可作值比较。你可以使用case class关键字来定义样例类。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7%E5%AF%B9%E8%B1%A1-%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%AE%83%E4%BB%AC%E8%87%AA%E5%B7%B1%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8D%95%E5%AE%9E%E4%BE%8B%EF%BC%8C%E4%BD%A0%E5%8F%AF%E4%BB%A5%E6%8A%8A%E5%AE%83%E7%9C%8B%E4%BD%9C%E5%AE%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%B1%BB%E7%9A%84%E5%8D%95%E4%BE%8B%E3%80%82"><span class="nav-number">2.7.</span> <span class="nav-text">2.7对象:对象是它们自己定义的单实例，你可以把它看作它自己的类的单例。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8%E7%89%B9%E8%B4%A8-%E7%89%B9%E8%B4%A8%E6%98%AF%E5%8C%85%E5%90%AB%E6%9F%90%E4%BA%9B%E5%AD%97%E6%AE%B5%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E7%B1%BB%E5%9E%8B%E3%80%82%E5%8F%AF%E4%BB%A5%E7%BB%84%E5%90%88%E5%A4%9A%E4%B8%AA%E7%89%B9%E8%B4%A8%E3%80%82"><span class="nav-number">2.8.</span> <span class="nav-text">2.8特质:特质是包含某些字段和方法的类型。可以组合多个特质。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9%E4%B8%BB%E6%96%B9%E6%B3%95-%E4%B8%BB%E6%96%B9%E6%B3%95%E6%98%AF%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%85%A5%E5%8F%A3%E7%82%B9%E3%80%82JVM%E8%A6%81%E6%B1%82%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BAmain%E7%9A%84%E4%B8%BB%E6%96%B9%E6%B3%95%EF%BC%8C%E6%8E%A5%E5%8F%97%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%82%E6%95%B0%E3%80%82"><span class="nav-number">2.9.</span> <span class="nav-text">2.9主方法:主方法是一个程序的入口点。JVM要求一个名为main的主方法，接受一个字符串数组的参数。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%BB%9F%E4%B8%80%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">3.统一类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1Scala%E7%B1%BB%E5%9E%8B%E5%B1%82%E7%BA%A7"><span class="nav-number">3.1.</span> <span class="nav-text">3.1Scala类型层级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96"><span class="nav-number">3.2.</span> <span class="nav-text">3.2类型转化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3Nothing%E5%92%8CNull"><span class="nav-number">3.3.</span> <span class="nav-text">3.3Nothing和Null</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%B1%BB"><span class="nav-number">4.</span> <span class="nav-text">4.类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="nav-number">4.1.</span> <span class="nav-text">4.1定义类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1%E6%A0%BC%E5%BC%8F%EF%BC%9Aclass-%E7%B1%BB%E5%90%8D-private-package-this-%E4%B8%BB%E6%9E%84%E9%80%A0%E5%99%A8%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8-extends-%E7%B1%BB-%E7%89%B9%E8%B4%A8-with-%E7%89%B9%E8%B4%A81-with-%E7%89%B9%E8%B4%A82"><span class="nav-number">4.1.1.</span> <span class="nav-text">4.1.1格式：class 类名 private[package&#x2F;this] (主构造器参数列表) extends 类&#x2F;特质 with 特质1 with 特质2{}</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2%E6%A1%88%E4%BE%8B%EF%BC%9A"><span class="nav-number">4.1.2.</span> <span class="nav-text">4.1.2案例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">4.2.</span> <span class="nav-text">4.2构造器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E6%A6%82%E5%BF%B5"><span class="nav-number">4.2.1.</span> <span class="nav-text">4.2.1:概念:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-%E4%B8%BB%E6%9E%84%E9%80%A0%E5%99%A8%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="nav-number">4.2.2.</span> <span class="nav-text">4.2.2 主构造器参数列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-%E6%A1%88%E4%BE%8B"><span class="nav-number">4.2.3.</span> <span class="nav-text">4.2.3:案例:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98%E5%92%8CGetter-Setter%E8%AF%AD%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">4.3私有成员和Getter&#x2F;Setter语法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E7%89%B9%E8%B4%A8"><span class="nav-number">5.</span> <span class="nav-text">5.特质</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1%E5%AE%9A%E4%B9%89%E7%89%B9%E8%B4%A8"><span class="nav-number">5.1.</span> <span class="nav-text">5.1定义特质:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2%E4%BD%BF%E7%94%A8%E7%89%B9%E8%B4%A8"><span class="nav-number">5.2.</span> <span class="nav-text">5.2使用特质:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.3.</span> <span class="nav-text">5.3子类型:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%85%83%E7%A5%96"><span class="nav-number">6.</span> <span class="nav-text">6.元祖</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0"><span class="nav-number">6.1.</span> <span class="nav-text">6.1访问元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2%E8%A7%A3%E6%9E%84%E5%85%83%E7%BB%84%E6%95%B0%E6%8D%AE"><span class="nav-number">6.2.</span> <span class="nav-text">6.2解构元组数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E9%80%9A%E8%BF%87%E6%B7%B7%E5%85%A5%EF%BC%88MIXIN%EF%BC%89%E6%9D%A5%E7%BB%84%E5%90%88%E7%B1%BB"><span class="nav-number">7.</span> <span class="nav-text">7.通过混入（MIXIN）来组合类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-number">8.</span> <span class="nav-text">8.高阶函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95%E4%B8%BA%E5%87%BD%E6%95%B0"><span class="nav-number">8.1.</span> <span class="nav-text">1.强制转换方法为函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8E%A5%E6%94%B6%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">8.2.</span> <span class="nav-text">2.接收函数作为参数的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">8.3.</span> <span class="nav-text">3.返回函数的函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E5%B5%8C%E5%A5%97%E6%96%B9%E6%B3%95"><span class="nav-number">9.</span> <span class="nav-text">9.嵌套方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E5%A4%9A%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%EF%BC%88%E6%9F%AF%E9%87%8C%E5%8C%96%EF%BC%89"><span class="nav-number">10.</span> <span class="nav-text">10.多参数列表（柯里化）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1"><span class="nav-number">11.</span> <span class="nav-text">11.单例对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1"><span class="nav-number">11.1.</span> <span class="nav-text">1.定义一个单例对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1"><span class="nav-number">11.2.</span> <span class="nav-text">2.伴生对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Java-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">11.3.</span> <span class="nav-text">3.Java 程序员的注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">12.</span> <span class="nav-text">12.正则表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E6%8F%90%E5%8F%96%E5%99%A8%E5%AF%B9%E8%B1%A1"><span class="nav-number">13.</span> <span class="nav-text">13.提取器对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-FOR-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">14.</span> <span class="nav-text">14.FOR 表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="nav-number">15.</span> <span class="nav-text">15.泛型类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="nav-number">15.1.</span> <span class="nav-text">1.定义一个泛型类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8"><span class="nav-number">15.2.</span> <span class="nav-text">2.使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E5%9E%8B%E5%8F%98"><span class="nav-number">16.</span> <span class="nav-text">16.型变</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8D%8F%E5%8F%98"><span class="nav-number">16.1.</span> <span class="nav-text">1.协变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%80%86%E5%8F%98"><span class="nav-number">16.2.</span> <span class="nav-text">2.逆变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%B8%8D%E5%8F%98"><span class="nav-number">16.3.</span> <span class="nav-text">3.不变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%85%B6%E4%BB%96%E4%BE%8B%E5%AD%90"><span class="nav-number">16.4.</span> <span class="nav-text">4.其他例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E4%B8%8E%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">16.5.</span> <span class="nav-text">5.与其他语言的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-%E7%B1%BB%E5%9E%8B%E4%B8%8A%E7%95%8C"><span class="nav-number">17.</span> <span class="nav-text">17.类型上界</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E7%B1%BB%E5%9E%8B%E4%B8%8B%E7%95%8C"><span class="nav-number">18.</span> <span class="nav-text">18.类型下界</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Qzhang"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Qzhang</p>
  <div class="site-description" itemprop="description">痛点才是奋斗点~</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jackzhangqing" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jackzhangqing" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jackcodingqing@gmail.com" title="E-Mail → mailto:jackcodingqing@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://m.weibo.cn/" title="Weibo → https:&#x2F;&#x2F;m.weibo.cn&#x2F;" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.csdn.net/" title="https:&#x2F;&#x2F;www.csdn.net&#x2F;" rel="noopener" target="_blank">CSDN</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    
    <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
    

     <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-08 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qzhang</span>
</div>
  <div class="powered-by">
    <!--由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动 -->
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
});
</script> 

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/01/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
